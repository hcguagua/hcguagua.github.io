<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Locust 性能测试</title>
    <link href="/2024/05/21/Locust-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/05/21/Locust-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="主流性能测试工具对比"><a href="#主流性能测试工具对比" class="headerlink" title="主流性能测试工具对比"></a><strong>主流性能测试工具对比</strong></h3><ol><li>JMeter<ol><li>优点:开源免费、易用性强、支持多种协议测试、可视化报告</li><li>缺点:性能测试能力较弱,对大并发和长时间测试支持不足</li></ol></li><li>Locust<ol><li>优点:开源免费、基于Python编写、易于编写复杂场景、分布式压测支持</li><li>缺点:仅支持HTTP&#x2F;WebSocket协议、编写压测脚本需要一定Python基础</li></ol></li><li>Gatling<ol><li>优点:性能优秀、支持多种协议、支持分布式压测、报告详细</li><li>缺点:学习曲线较steep、需要一定Scala编程能力</li></ol></li><li>Loadrunner<ol><li>优点:功能全面、支持多种协议、报告丰富、专业性强</li><li>缺点:需要付费授权、使用复杂度高、对测试人员技能要求高</li></ol></li><li>Siege<ol><li>优点:开源免费、易于上手、针对HTTP&#x2F;HTTPS协议优化良好</li><li>缺点:功能较为简单、不支持分布式压测、报告信息较少</li></ol></li><li>Artillery<ol><li>优点:开源免费、易于上手、支持多种协议、可定制化程度高</li><li>缺点:性能相对较弱、报告信息较少、社区活跃度不高</li></ol></li></ol><h3 id="Locust相关文档"><a href="#Locust相关文档" class="headerlink" title="Locust相关文档"></a><strong>Locust相关文档</strong></h3><p>github地址：<a href="https://github.com/locustio/locust">https://github.com/locustio/locust</a></p><p>官方文档地址：<a href="https://docs.locust.io/">docs.locust.io</a></p><h3 id="常见的上线策略"><a href="#常见的上线策略" class="headerlink" title="常见的上线策略"></a><strong>常见的上线策略</strong></h3><ol><li>金丝雀发布(Canary Release):<ol><li>将新版本先部署给少量代表性用户(金丝雀用户组),监控使用情况。</li><li>确认无重大问题后,逐步扩大新版本的发布范围。</li></ol></li><li>蓝绿部署(Blue-Green Deployment):<ol><li>在生产环境中维护两套完全相同的环境(蓝色和绿色)。</li><li>新版本先部署到其中一个环境,测试无误后切换流量。</li></ol></li><li>灰度发布(Gradual Rollout):<ol><li>将新版本逐步推广到用户群中,如先发布给少部分用户。</li><li>监控反馈情况,确认无重大问题后再扩大发布范围。</li></ol></li><li>A&#x2F;B测试(A&#x2F;B Testing):<ol><li>将用户分成A&#x2F;B两组,A组使用旧版本,B组使用新版本。</li><li>对比两组用户行为数据,评估新功能的影响。</li></ol></li><li>功能开关(Feature Flags):<ol><li>将新功能与主干代码解耦,可以控制新功能在生产环境的开启时机。</li><li>方便快速回滚和测试新功能。</li></ol></li><li>分阶段推广(Incremental Rollout):<ol><li>将新版本分阶段推广到用户群中,先让少部分用户试用。</li><li>观察反馈情况,确认无重大问题后再逐步扩大范围。</li></ol></li></ol><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h3><ol><li><p>安装：直接 pip 安装就行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pip3</span> install locust<br><br><span class="hljs-comment"># 查看版本</span><br><span class="hljs-attribute">locust</span> -V<br><br><span class="hljs-comment"># 输出类似下面的内容就代表安装成功了！！！</span><br><span class="hljs-attribute">locust</span> <span class="hljs-number">2</span>.<span class="hljs-number">27</span>.<span class="hljs-number">0</span> from /usr/local/lib/python3.<span class="hljs-number">10</span>/site-packages/locust (python <span class="hljs-number">3</span>.<span class="hljs-number">10</span>.<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure></li><li><p>案例模版（需要新建 名为 locustfile.py  的文件）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> locust <span class="hljs-keyword">import</span> HttpUser, task, between<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldUser</span>(<span class="hljs-title class_ inherited__">HttpUser</span>):<br>    host = <span class="hljs-string">&#x27;http://120.46.177.228&#x27;</span><br>    wait_time = between(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-meta">    @task</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">webhook</span>(<span class="hljs-params">self</span>):<br>        self.client.post(<span class="hljs-string">&#x27;/webhook1&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>终端运行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">locust<br><br><span class="hljs-comment"># 启动多个节点</span><br>什么是分布式负载生成?<br>Locust支持跨多个进程和机器运行负载测试,以产生更高水平的负载。<br>这是通过运行一个Locust实例在主节点模式,以及一个或多个实例在工作节点模式来实现的。<br>主节点运行Web UI并协调工作节点,而工作节点运行实际的用户模拟。<br>在单台机器上运行<br>要在单台机器上以分布式方式运行Locust,可以使用<span class="hljs-params">--processes</span>标志启动主节点和多个工作节点进程。<br>例如: locust <span class="hljs-params">--processes</span> 4 将启动1个主节点和4个工作节点进程。<br>您也可以使用 <span class="hljs-params">--processes</span> -1 自动检测逻辑核心数并为每个核心启动一个工作节点。<br>在多台机器上运行<br>在一台机器上以locust <span class="hljs-params">--master</span>启动主节点实例。<br>然后在每台工作节点机器上运行locust <span class="hljs-params">--worker</span> <span class="hljs-params">--master-host</span> &lt;主节点主机&gt;。<br>您也可以使用locust-swarm工具来自动化分布式设置并处理防火墙/网络访问问题。<br>分布式选项<br><span class="hljs-params">--master-host</span>: 设置主节点的主机名<span class="hljs-string">/IP</span><span class="hljs-params">(默认为localhost)</span>。<br><span class="hljs-params">--master-port</span>: 设置主节点的端口号<span class="hljs-params">(默认为5557)</span>。<br><span class="hljs-params">--master-bind-host</span>: 确定主节点将绑定的网络接口<span class="hljs-params">(默认为全部)</span>。<br><span class="hljs-params">--master-bind-port</span>: 确定主节点将监听的网络端口<span class="hljs-params">(默认为5557)</span>。<br><span class="hljs-params">--expect-workers</span>: 与<span class="hljs-params">--headless</span>模式一起使用,等待指定数量的工作节点连接后再开始测试。<br>跨节点通信<br>您可以使用内置的事件钩子实现主节点和工作节点之间的自定义消息传递。<br>这允许在分布式设置中协调测试设置和其他功能。<br>提高Locust性能<br>如果您正在运行大规模测试,请考虑使用更快的FastHttpUser而不是默认的HttpUser。<br>这可以大大提高Locust的性能。<br></code></pre></td></tr></table></figure></li><li><p>访问 <a href="http://localhost:8089/">http://localhost:8089/</a> </p><ol><li>Number of users (peak concurrency)  –&gt; 用户数量（高峰并发） </li><li>Ramp up (users started&#x2F;second)  –&gt; 递增用户数量</li><li>Host –&gt; 主机域名</li><li>Advanced options –&gt; 可选项<ol><li>Run time –&gt; 运行时间</li></ol></li></ol></li><li><p>相关页面 性能测试指标</p><ol><li>Statistics【表格数据】</li><li>Charts【图表数据】<ol><li>Total Requests per Secend<ol><li>RPS</li><li>Failures&#x2F;s</li></ol></li><li>Response Times(ms)<ol><li>95th Percentile</li><li>Average Response Time</li></ol></li><li>Number of Users</li></ol></li></ol></li></ol><h3 id="指标说明"><a href="#指标说明" class="headerlink" title="指标说明"></a><strong>指标说明</strong></h3><p><img src="/../imgs/image.png" alt="img"><img src="/../imgs/image-1716222963213.png" alt="img"></p><h4 id="Statistics页面部分"><a href="#Statistics页面部分" class="headerlink" title="Statistics页面部分"></a><strong>Statistics页面部分</strong></h4><ol><li>Type：请求方式</li><li>Name：接口路由</li><li>Requests：请求数量</li><li>Fails：请求失败的数量</li><li>Median：响应时间中位数</li><li>95%ile(ms)：95% 响应时间。表示 95% 的请求在这个时间内完成。</li><li>99%ile(ms)：99% 响应时间。表示 99% 的请求在这个时间内完成。</li><li>Average(ms)：平均响应时间</li><li>Min(ms)：最小响应时间</li><li>Max(ms)：最大响应时间</li><li>Average size (bytes)：每个请求的平均响应数据大小,单位为字节。</li><li>Current RPS：当前的每秒请求数。</li><li>Current Failures&#x2F;s：每秒钟发生的失败请求数量。</li></ol><h4 id="Charts页面部分"><a href="#Charts页面部分" class="headerlink" title="Charts页面部分"></a><strong>Charts页面部分</strong></h4><ol><li>RPS (Requests per Second)：每秒请求数。表示每秒发送的请求数量。这个指标用来衡量系统的吞吐量。</li><li>Failures&#x2F;s：每秒失败数。表示每秒发生的失败请求数量。这帮助用户了解失败请求的频率。</li><li>95th Percentile：95 百分位数。表示响应时间分布中,有95%的响应时间小于等于这个值。它反映了系统在高负载下的响应性能。</li><li>Average Response Time：平均响应时间。所有请求的平均响应时间。这个指标反映了系统的总体响应性能。</li><li>Number of Users：用户数。当前运行的虚拟用户数，代表正在模拟的并发用户数量。</li></ol><h3 id="发现性能瓶颈简略步骤"><a href="#发现性能瓶颈简略步骤" class="headerlink" title="发现性能瓶颈简略步骤"></a><strong>发现性能瓶颈简略步骤</strong></h3><p>以下现象表示 服务器系统处理请求的效率下降。</p><ul><li>RPS 不再增加，甚至有所下降，表明系统已经无法处理更多的请求。</li><li>失败请求数增加，表明部分请求由于系统资源不足而无法成功处理。</li><li>系统资源（特别是 CPU）使用率达到 100%，表明系统资源已被完全占用。</li></ul><h4 id="1-逐步增加并发用户数"><a href="#1-逐步增加并发用户数" class="headerlink" title="1. 逐步增加并发用户数"></a><strong>1. 逐步增加并发用户数</strong></h4><p>每次增加 20 个并发用户，例如从 50 增加到 70，再到 90 等等。每次增加后，观察并记录以下指标：</p><ul><li>平均响应时间</li><li>95th 百分位响应时间</li><li>RPS</li><li>失败请求数</li><li>系统资源使用率（可以通过系统监控工具如 <code>htop</code>、<code>top</code> 或 <code>vmstat</code> 进行监控）</li></ul><h4 id="2-找到系统极限"><a href="#2-找到系统极限" class="headerlink" title="2. 找到系统极限"></a><strong>2. 找到系统极限</strong></h4><p>继续增加并发用户数，直到发现以下情况之一：</p><ul><li>响应时间显著增加（例如从 800ms 增加到 2500ms）。</li><li>RPS 不再增加或下降（例如从 45 RPS 降到 40 RPS）。</li><li>失败请求数显著增加（例如从 0 增加到 15）。</li><li>系统资源（特别是 CPU 或内存）使用率达到 100%。</li></ul><h4 id="3-示例结果"><a href="#3-示例结果" class="headerlink" title="3. 示例结果"></a><strong>3. 示例结果</strong></h4><p>假设以下是你逐步增加并发用户数后的观察结果：</p><table><thead><tr><th align="center">并发用户数</th><th align="center">平均响应时间</th><th align="center">95th 响应时间</th><th align="center">RPS</th><th align="center">失败请求数</th><th align="center">CPU 使用率</th></tr></thead><tbody><tr><td align="center">50</td><td align="center">800 ms</td><td align="center">1300 ms</td><td align="center">35</td><td align="center">0</td><td align="center">50%</td></tr><tr><td align="center">70</td><td align="center">850 ms</td><td align="center">1350 ms</td><td align="center">40</td><td align="center">0</td><td align="center">60%</td></tr><tr><td align="center">90</td><td align="center">900 ms</td><td align="center">1400 ms</td><td align="center">43</td><td align="center">2</td><td align="center">75%</td></tr><tr><td align="center">110</td><td align="center">1500 ms</td><td align="center">2000 ms</td><td align="center">45</td><td align="center">5</td><td align="center">90%</td></tr><tr><td align="center">130</td><td align="center">2500 ms</td><td align="center">3000 ms</td><td align="center">40</td><td align="center">15</td><td align="center">100%</td></tr></tbody></table><p>在并发用户数达到 130 时，系统各项指标表明已达到瓶颈：</p><ul><li>平均响应时间显著增加到 2500 ms。</li><li>RPS 不再增加，甚至有所下降到 40。</li><li>失败请求数显著增加到 15。</li><li>CPU 使用率达到 100%。</li></ul><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h4><p>在这个示例中，系统的并发瓶颈大约在 130 并发用户左右。当并发用户数超过 130 时，系统的响应时间显著增加，RPS 不再增加，并且失败请求数显著增加，同时 CPU 使用率达到了 100%。</p><p>通过这些步骤和分析，你可以确定系统的性能瓶颈和最大支持的并发用户数，并进行相应的优化和调整。</p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Locust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>playwright</title>
    <link href="/2024/05/08/playwright/"/>
    <url>/2024/05/08/playwright/</url>
    
    <content type="html"><![CDATA[<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs clean"># <span class="hljs-keyword">import</span> time<br>#<br># <span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> Playwright, sync_playwright<br># <span class="hljs-keyword">import</span> subprocess<br>#<br># # 输入 Chrome 浏览器所在路径，并使用双引号将路径括起来<br># # chrome_path = <span class="hljs-string">&#x27;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#x27;</span><br># chrome_path = <span class="hljs-string">&quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe&quot;</span><br># debugging_port = <span class="hljs-string">&#x27;--remote-debugging-port=9223&#x27;</span><br>#<br># # 使用列表形式表示命令及其参数<br># command = [chrome_path, debugging_port]<br># subprocess.Popen(command)<br>#<br>#<br># def run(playwright: Playwright) -&gt; None:<br>#     # browser = playwright.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>#     time.sleep(<span class="hljs-number">4</span>)<br>#     browser = playwright.chromium.connect_over_cdp(<span class="hljs-string">&#x27;http://localhost:9223&#x27;</span>)<br>#     default_context = browser.contexts[<span class="hljs-number">0</span>]<br>#     page = default_context.pages[<span class="hljs-number">0</span>]<br>#     print(page)<br>#<br>#     page = default_context.new_page()<br>#     page.goto(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>#<br>#<br># # 在这里调用 run() 函数<br># <span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> playwright:<br>#     run(playwright)<br><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> Playwright, sync_playwright<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> playwright:<br>    browser = playwright.chromium.launch_persistent_context(<br>        # 指定本机用户缓存地址<br>        user_data_dir=r<span class="hljs-string">&quot;C:\Users\Jay\Desktop\截图\user&quot;</span>,<br>        # 指定本机google客户端exe的路径<br>        executable_path=<span class="hljs-string">&quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe&quot;</span>,<br>        # 要想通过这个下载文件这个必然要开  默认是<span class="hljs-literal">False</span><br>        accept_downloads=<span class="hljs-literal">True</span>,<br>        # 设置不是无头模式<br>        headless=<span class="hljs-literal">False</span>,<br>        bypass_csp=<span class="hljs-literal">True</span>,<br>        slow_mo=<span class="hljs-number">10</span>,<br>        # 跳过检测<br>        args=[<span class="hljs-string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>, <span class="hljs-string">&#x27;--remote-debugging-port=9222&#x27;</span>]<br><br>    )<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://console.ccpayment.com/balances/index&quot;</span>)<br>    # time.sleep(<span class="hljs-number">1000</span>)<br>    page.get_by_role(<span class="hljs-string">&quot;row&quot;</span>, name=<span class="hljs-string">&quot;logo TETH&quot;</span>).get_by_role(<span class="hljs-string">&quot;button&quot;</span>).nth(<span class="hljs-number">1</span>).click()<br>    page.get_by_label(<span class="hljs-string">&quot;Enter Address&quot;</span>).click()<br>    page.get_by_label(<span class="hljs-string">&quot;Enter Address&quot;</span>).fill(<span class="hljs-string">&quot;0x12438F04093EBc87f0Ba629bbe93F2451711d967&quot;</span>)<br>    page.get_by_label(<span class="hljs-string">&quot;Amount&quot;</span>).click()<br>    page.get_by_label(<span class="hljs-string">&quot;Amount&quot;</span>).fill(<span class="hljs-string">&quot;0.002&quot;</span>)<br>    page.get_by_role(<span class="hljs-string">&quot;button&quot;</span>, name=<span class="hljs-string">&quot;Send&quot;</span>).click()<br>    page.get_by_label(<span class="hljs-string">&quot;Payment Password&quot;</span>).click()<br>    page.get_by_label(<span class="hljs-string">&quot;Payment Password&quot;</span>).fill(<span class="hljs-string">&quot;111111&quot;</span>)<br>    page.get_by_role(<span class="hljs-string">&quot;button&quot;</span>, name=<span class="hljs-string">&quot;Confirm&quot;</span>).click()<br>    time.sleep(<span class="hljs-number">2</span>)<br>    page.get_by_label(<span class="hljs-string">&quot;close&quot;</span>).click()<br>    # print(page.title())<br>    time.sleep(<span class="hljs-number">200</span>)<br>    browser.close()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UI自动化</tag>
      
      <tag>playwright</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3示例Demo</title>
    <link href="/2024/01/28/Vue3%E7%A4%BA%E4%BE%8BDemo/"/>
    <url>/2024/01/28/Vue3%E7%A4%BA%E4%BE%8BDemo/</url>
    
    <content type="html"><![CDATA[<p>一个较完整的表格展示页，包括基本的增删改查、分页、搜索功能；</p><p>相关技术栈：Vue3 + element-plus + axios</p><p><img src="/../imgs/1717091333671.png" alt="1717091333671"></p><h1 id="接口返回的JSON格式"><a href="#接口返回的JSON格式" class="headerlink" title="接口返回的JSON格式"></a>接口返回的JSON格式</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  &quot;<span class="hljs-selector-tag">code</span>&quot;: <span class="hljs-string">&quot;1000&quot;</span>,<br>  <span class="hljs-string">&quot;msg&quot;</span>: [<br>    &#123;<br>      &quot;id&quot;: <span class="hljs-number">89</span>,<br>      <span class="hljs-string">&quot;book_name&quot;</span>: <span class="hljs-string">&quot;kkax&quot;</span>,<br>      <span class="hljs-string">&quot;book_price&quot;</span>: <span class="hljs-string">&quot;12&quot;</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单组件实现"><a href="#单组件实现" class="headerlink" title="单组件实现"></a>单组件实现</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div style=&quot;height: 600px; width: 700px; border: 1px solid black; margin: 0 auto; padding: 5px;&quot;&gt;<br>        &lt;!-- 增肌书籍按钮 --&gt;<br>        &lt;el-button plain type=&quot;primary&quot; @click=&quot;openDialog(&#x27;add&#x27;)&quot;&gt;增加&lt;/el-button&gt;<br>        &lt;hr /&gt;<br>        &lt;!-- 书名搜索框 --&gt;<br>        &lt;div class=&quot;search-box&quot;&gt;<br>            &lt;el-input v-model=&quot;searchText&quot; placeholder=&quot;搜索书名&quot; @input=&quot;handleSearch&quot;&gt;&lt;/el-input&gt;<br>        &lt;/div&gt;<br>        &lt;!-- 所以书籍数据表格 --&gt;<br>        &lt;el-table :data=&quot;paginatedData&quot; style=&quot;width: 100%;&quot;&gt;<br>            &lt;el-table-column label=&quot;书名&quot; width=&quot;180px&quot; prop=&quot;book_name&quot;&gt;&lt;/el-table-column&gt;<br>            &lt;el-table-column label=&quot;价格&quot; width=&quot;180px&quot; prop=&quot;book_price&quot;&gt;&lt;/el-table-column&gt;<br>            &lt;el-table-column label=&quot;操作&quot;&gt;<br>                &lt;template #default=&quot;&#123; row &#125;&quot;&gt;<br>                    &lt;el-button size=&quot;small&quot; type=&quot;primary&quot; @click=&quot;openDialog(&#x27;edit&#x27;, row)&quot;&gt;编辑&lt;/el-button&gt;<br>                    &lt;el-button size=&quot;small&quot; type=&quot;danger&quot; @click=&quot;confirmOpen(row)&quot;&gt;删除&lt;/el-button&gt;<br>                &lt;/template&gt;<br>            &lt;/el-table-column&gt;<br>        &lt;/el-table&gt;<br>        &lt;hr /&gt;<br>        &lt;!-- 分页组件--&gt;<br>        &lt;el-pagination background layout=&quot;prev, pager, next, total&quot; :page-size=&quot;10&quot; :total=&quot;filteredData.length&quot;<br>            @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot;&gt;<br>        &lt;/el-pagination&gt;<br>        &lt;!-- 新增/编辑表单 --&gt;<br>        &lt;el-dialog v-model=&quot;dialogVisible&quot; :title=&quot;dialogType === &#x27;add&#x27; ? &#x27;新增&#x27; : &#x27;编辑&#x27;&quot; width=&quot;400px&quot;&gt;<br>            &lt;el-form&gt;<br>                &lt;el-form-item label=&quot;书名&quot;&gt;<br>                    &lt;el-input placeholder=&quot;请输入书名&quot; v-model=&quot;form.book_name&quot; /&gt;<br>                &lt;/el-form-item&gt;<br>                &lt;el-form-item label=&quot;价格&quot;&gt;<br>                    &lt;el-input placeholder=&quot;请输入价格&quot; v-model=&quot;form.book_price&quot; /&gt;<br>                &lt;/el-form-item&gt;<br>            &lt;/el-form&gt;<br>            &lt;template #footer&gt;<br>                &lt;div class=&quot;dialog-footer&quot;&gt;<br>                    &lt;el-button @click=&quot;closeDialog&quot;&gt;取消&lt;/el-button&gt;<br>                    &lt;el-button type=&quot;primary&quot; @click=&quot;dialogType === &#x27;add&#x27; ? onAdd() : onUpdate()&quot;&gt;确认&lt;/el-button&gt;<br>                &lt;/div&gt;<br>            &lt;/template&gt;<br>        &lt;/el-dialog&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import axios from &#x27;axios&#x27;;<br>import &#123; ref, onMounted, computed &#125; from &#x27;vue&#x27;;<br>import &#123; ElMessage, ElMessageBox &#125; from &#x27;element-plus&#x27;<br><br>const apiUrl = &#x27;http://127.0.0.1:8000/web/books2/&#x27;;<br>const apiUrl2 = &#x27;http://127.0.0.1:8000/web/book2/&#x27;;<br><br>const list = ref([]);<br>const form = ref(&#123;<br>    book_name: &#x27;&#x27;,<br>    book_price: &#x27;&#x27;,<br>&#125;);<br>const dialogVisible = ref(false);<br>const dialogType = ref(&#x27;add&#x27;); // &#x27;add&#x27; or &#x27;edit&#x27;<br>let editingBookId = null;<br>const searchText = ref(&#x27;&#x27;);<br><br>//获取所有书籍数据<br>const getList = async () =&gt; &#123;<br>    try &#123;<br>        const res = await axios.get(apiUrl);<br>        if (res.data.code === &#x27;1000&#x27;) &#123;<br>            list.value = res.data.msg;<br>        &#125; else &#123;<br>            console.error(&#x27;Error fetching data&#x27;, res.data);<br>        &#125;<br>    &#125; catch (error) &#123;<br>        console.error(&#x27;Error fetching data&#x27;, error);<br>    &#125;;<br>&#125;;<br><br>onMounted(() =&gt; getList())<br><br>const currentPage = ref(1);<br>const pageSize = ref(10);<br><br>// 计算分页后的数组<br>const paginatedData = computed(() =&gt; &#123;<br>    const startIndex = (currentPage.value - 1) * pageSize.value;<br>    const endIndex = startIndex + pageSize.value;<br>    return list.value.filter(item =&gt; item.book_name.includes(searchText.value)).slice(startIndex, endIndex);<br>&#125;);<br><br>const filteredData = computed(() =&gt; &#123;<br>    return list.value.filter(item =&gt; item.book_name.includes(searchText.value));<br>&#125;);<br><br>// 处理每页显示条数变化<br>const handleSizeChange = (newSize) =&gt; &#123;<br>    pageSize.value = newSize;<br>    currentPage.value = 1; // 回到第一页<br>&#125;;<br><br>// 处理页码变化<br>const handleCurrentChange = (newPage) =&gt; &#123;<br>    currentPage.value = newPage;<br>&#125;;<br><br>// 处理搜索<br>const handleSearch = () =&gt; &#123;<br>    currentPage.value = 1; // 回到第一页<br>&#125;;<br><br>// 打开Dialog<br>const openDialog = (type, row = null) =&gt; &#123;<br>    dialogType.value = type;<br>    if (type === &#x27;edit&#x27;) &#123;<br>        editingBookId = row.id;<br>        form.value.book_name = row.book_name;<br>        form.value.book_price = row.book_price;<br>    &#125; else &#123;<br>        form.value.book_name = &#x27;&#x27;;<br>        form.value.book_price = &#x27;&#x27;;<br>    &#125;<br>    dialogVisible.value = true;<br>&#125;;<br><br>const closeDialog = () =&gt; &#123;<br>    dialogVisible.value = false;<br>&#125;;<br><br>// 操作成功消息提示<br>const openSuccess = (type) =&gt; &#123;<br>    ElMessage(&#123;<br>        showClose: true,<br>        message: type === &#x27;add&#x27; ? &#x27;添加成功！&#x27; : &#x27;修改成功！&#x27;,<br>        type: &#x27;success&#x27;,<br>    &#125;)<br>&#125;<br><br>// 操作失败消息提示<br>const openFailed = () =&gt; &#123;<br>    ElMessage(&#123;<br>        showClose: true,<br>        message: &#x27;数据格式错误！ 请检查&#x27;,<br>        type: &#x27;error&#x27;,<br>    &#125;)<br>&#125;<br><br>// 新增书籍<br>const onAdd = async () =&gt; &#123;<br>    try &#123;<br>        const res = await axios.post(apiUrl, &#123;<br>            book_name: form.value.book_name,<br>            book_price: form.value.book_price,<br>        &#125;);<br>        console.log(res.data.code)<br>        if (res.data.code === 1000) &#123;<br>            closeDialog();<br>            openSuccess(&quot;add&quot;);<br>            getList();<br>        &#125; else &#123;<br>            console.error(&#x27;Error fetching data&#x27;, res.data);<br>            openFailed();<br>        &#125;<br>    &#125; catch (error) &#123;<br>        console.error(&#x27;Error fetching data&#x27;, error);<br>    &#125;;<br>&#125;;<br><br>// 修改书籍<br>const onUpdate = async () =&gt; &#123;<br>    await axios.put(`$&#123;apiUrl2&#125;$&#123;editingBookId&#125;/`, &#123;<br>        book_name: form.value.book_name,<br>        book_price: form.value.book_price,<br>    &#125;);<br>    closeDialog();<br>    openSuccess(&quot;edit&quot;);<br>    getList();<br>&#125;;<br><br>// 删除书籍<br>const onDelete = async (id) =&gt; &#123;<br>    await axios.delete(`$&#123;apiUrl2&#125;$&#123;id&#125;/`);<br>    getList()<br>&#125;<br><br>// 是否删除 消息弹出框<br>const confirmOpen = (row) =&gt; &#123;<br>    ElMessageBox.confirm(<br>        &#x27;删除不可恢复，是否继续?&#x27;,<br>        &#123;<br>            confirmButtonText: &#x27;OK&#x27;,<br>            cancelButtonText: &#x27;Cancel&#x27;,<br>            type: &#x27;error&#x27;,<br>        &#125;<br>    )<br>        .then(() =&gt; &#123;<br>            onDelete(row.id)<br>            ElMessage(&#123;<br>                type: &#x27;success&#x27;,<br>                message: &#x27;Delete completed&#x27;,<br>            &#125;)<br>        &#125;)<br>        .catch(() =&gt; &#123;<br>            ElMessage(&#123;<br>                type: &#x27;info&#x27;,<br>                message: &#x27;Delete canceled&#x27;,<br>            &#125;)<br>        &#125;)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h1 id="父子组件实现"><a href="#父子组件实现" class="headerlink" title="父子组件实现"></a>父子组件实现</h1><h2 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import Edit from &#x27;./components/form/Edit.vue&#x27;<br>import Add from &#x27;./components/form/Add.vue&#x27;<br>import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;<br>import axios from &#x27;axios&#x27;;<br><br><br>//1. 获取列表<br>const list = ref([])<br>const getList = async () =&gt; &#123;<br>  const res = await axios.get(&#x27;http://127.0.0.1:8000/web/books2/&#x27;)<br>  if (res.data.code === &quot;1000&quot;) &#123;<br>    list.value = res.data.msg<br>  &#125; else &#123;<br>    console.error(&#x27;Error fetching data&#x27;, res.data)<br>  &#125;<br>&#125;<br><br>onMounted(() =&gt; getList())<br><br>//2. 删除记录 <br>const onDelete = async (id) =&gt; &#123;<br>  console.log(id);<br>  await axios.delete(`http://127.0.0.1:8000/web/book2/$&#123;id&#125;/`);<br>  getList()<br>&#125;<br><br>//3. 编辑 ： 打开弹窗-&gt; 回填数据-&gt; 更新数据<br>// 打开弹窗: 获取子组件实例 调用方法或者修改属性<br>//回弹数据（掉接口 / 当前行的数据）<br>const editRef = ref(null)<br>const onEdit = (row) =&gt; &#123;<br>  editRef.value.open(row)<br>&#125;<br><br>//新增书籍：打开弹窗=》填写数据=》更新数据<br>const addRef = ref(null)<br>const onAdd = () =&gt; &#123;<br>  addRef.value.open()<br>&#125;<br><br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div style=&quot;height: 500px;width: 1000px;border: 1px solid black;margin:0 auto;padding: 5px;&quot;&gt;<br>    &lt;el-button plain type=&quot;primary&quot; @click=&quot;onAdd()&quot;&gt;增加&lt;/el-button&gt;<br><br>    &lt;hr&gt;<br>    &lt;el-table :data=&quot;list&quot; style=&quot;width: 100%&quot;&gt;<br>      &lt;el-table-column label=&quot;书名&quot; width=&quot;180px&quot; prop=&quot;book_name&quot;&gt;&lt;/el-table-column&gt;<br>      &lt;el-table-column label=&quot;价格&quot; width=&quot;180px&quot; prop=&quot;book_price&quot;&gt; &lt;/el-table-column&gt;<br>      &lt;el-table-column label=&quot;操作&quot;&gt;<br>        &lt;template #default=&quot;&#123; row &#125;&quot;&gt;<br>          &lt;el-button size=&quot;small&quot; type=&quot;primary&quot; @click=&quot;onEdit(row)&quot;&gt;编辑&lt;/el-button&gt;<br>          &lt;el-button size=&quot;small&quot; type=&quot;danger&quot; @click=&quot;onDelete(row.id)&quot;&gt;删除&lt;/el-button&gt;<br>        &lt;/template&gt;<br>      &lt;/el-table-column&gt;<br>    &lt;/el-table&gt;<br><br>  &lt;/div&gt;<br><br>  &lt;Edit ref=&quot;editRef&quot; @on-update=&quot;getList&quot; /&gt;<br>  &lt;Add ref=&quot;addRef&quot; @on-add=&quot;getList&quot; /&gt;<br><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h2 id="子组件Edit"><a href="#子组件Edit" class="headerlink" title="子组件Edit"></a>子组件Edit</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> dialogVisible = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> form = <span class="hljs-title function_">ref</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">book_name</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">book_price</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">open</span> = (<span class="hljs-params">row</span>) =&gt; &#123;</span><br><span class="language-javascript">    form.<span class="hljs-property">value</span>.<span class="hljs-property">id</span> = row.<span class="hljs-property">id</span></span><br><span class="language-javascript">    form.<span class="hljs-property">value</span>.<span class="hljs-property">book_name</span> = row.<span class="hljs-property">book_name</span></span><br><span class="language-javascript">    form.<span class="hljs-property">value</span>.<span class="hljs-property">book_price</span> = row.<span class="hljs-property">book_price</span></span><br><span class="language-javascript">    dialogVisible.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">defineExpose</span>(&#123;</span><br><span class="language-javascript">    open</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;on-update&#x27;</span>])</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">onUpdate</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">put</span>(<span class="hljs-string">`http://127.0.0.1:8000/web/book2/<span class="hljs-subst">$&#123;form.value.id&#125;</span>/`</span>, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">book_name</span>: form.<span class="hljs-property">value</span>.<span class="hljs-property">book_name</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">book_price</span>: form.<span class="hljs-property">value</span>.<span class="hljs-property">book_price</span></span><br><span class="language-javascript">    &#125;),</span><br><span class="language-javascript">        dialogVisible.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">        <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;on-update&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-dialog</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;dialogVisible&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;编辑&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400px&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">el-form</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;书名&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;书名&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;form.book_name&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;价格&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;价格&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;form.book_price&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">el-form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog-footer&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;dialogVisible = false&quot;</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onUpdate()&quot;</span>&gt;</span>确认<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-dialog</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="子组件Add"><a href="#子组件Add" class="headerlink" title="子组件Add"></a>子组件Add</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> dialogVisible = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> form = <span class="hljs-title function_">ref</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">book_name</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">book_price</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">open</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">    form.<span class="hljs-property">value</span>.<span class="hljs-property">book_name</span> = <span class="hljs-literal">null</span>;</span><br><span class="language-javascript">    form.<span class="hljs-property">value</span>.<span class="hljs-property">book_price</span> = <span class="hljs-literal">null</span>;</span><br><span class="language-javascript">    dialogVisible.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-title function_">defineExpose</span>(&#123;</span><br><span class="language-javascript">    open</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;on-add&#x27;</span>])</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">onAdd</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">`http://127.0.0.1:8000/web/books2/`</span>, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">book_name</span>: form.<span class="hljs-property">value</span>.<span class="hljs-property">book_name</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">book_price</span>: form.<span class="hljs-property">value</span>.<span class="hljs-property">book_price</span></span><br><span class="language-javascript">    &#125;),</span><br><span class="language-javascript">        dialogVisible.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">        <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;on-add&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-dialog</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;dialogVisible&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;新增&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400px&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">el-form</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;书名&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入书名&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;form.book_name&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;价格&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入价格&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;form.book_price&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">el-form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog-footer&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;dialogVisible = false&quot;</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onAdd()&quot;</span>&gt;</span>确认<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-dialog</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
      <tag>element-plus</tag>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链</title>
    <link href="/2023/08/01/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <url>/2023/08/01/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="第一节：从比特币到区块链"><a href="#第一节：从比特币到区块链" class="headerlink" title="第一节：从比特币到区块链"></a>第一节：从比特币到区块链</h1><p>比特币：Bitcoin（BTC）</p><ul><li>无需信任第三方</li><li>点对点交易，全球流通性</li><li>安全性、隐私性、可追溯、交易的不可篡改</li></ul><p>数字货币：</p><p><strong>无中心化的发行机构,<strong>通过计算机程序和一定的机制发行货币,并通过技术保证货币发行量及交易的安全性数字货币通常也叫</strong>加密货币</strong>。</p><p>比特币发放形式：</p><ul><li>每10分钟左右随着一个新区块被创建,规定数量的比特币奖励给创建者;</li><li>奖励数量每四年减半一次,最初创建一个区块奖励50btc,产生到21万个区块之后,降为25btc,后面依次对半递减。</li></ul><p>比特币总量：</p><ul><li><p>上限2100万个</p></li><li><p>预计2140年左右全部挖出;目前已挖出近1800万个左右</p></li><li><p>由于私钥丢失、硬盘损坏等种种原因有上百万BTC已经相当长时间未移动</p></li></ul><p>区块链：分布式账本技术</p><p>一个人记账是不安全的，而多人同时记账是难以统一的。</p><p>区块链技术使得多人的分布式记账可以达成统一，是比特币运行的机理。</p><p><img src="/../imgs/1692115781989.png" alt="1692115781989"></p><h1 id="第二节：区块链的运行机制"><a href="#第二节：区块链的运行机制" class="headerlink" title="第二节：区块链的运行机制"></a>第二节：区块链的运行机制</h1><p><img src="/../imgs/1692116315945.png" alt="1692116315945"></p><ol><li>交易：分布式账本的参与者发生交易，导致账本状态的改变。</li><li>区块：记录一段时间内发生的所有交易和状态结果，更新账本状态。</li><li>区块链：区块按时间顺序串联，账本状态变化的精确日志记录，最新区块代表账本的最新状态。</li></ol><p>账户体系：公钥和私钥</p><ul><li>公钥：区块链世界里的账号</li><li>私钥：区块链世界里的密码</li></ul><p>传统账户体系：</p><ul><li>传统账户体系中,账户名、密码与对应关系存储在中心化数据库里</li><li>验证时,通过比对数据库中的数据来验证</li><li>中心化数据库有管理员作恶、被攻击盗取等风险</li></ul><p>区块链体系：  </p><ul><li>随机生成私钥,通过数学加密曲线生成公钥</li><li>公钥与私钥存在数学关系,可以直接验证</li><li>椭圆加密曲线函数</li><li><strong>公钥对外公开，你保留私钥，私钥通过加密曲线生成公钥来证明你是公钥的拥有者（私钥和公钥之间通过某种函数产生了映射关系，但是外界无法通过公钥去计算出私钥）</strong></li></ul><p>交易过程：</p><p><img src="/../imgs/1692715753230.png" alt="1692715753230"></p><p>挖矿：竞争记账权</p><p><img src="/../imgs/1692715970735.png" alt="1692715970735"></p><p>记账验证</p><p><img src="/../imgs/1692716169095.png" alt="1692716169095"></p><p><img src="/../imgs/1692716201907.png" alt="1692716201907"></p><p>UTXO模型：</p><p>未花费的交易输出：unspent transacation output</p><p>关键点：重点记录交易而非余额</p><ul><li>传统账户交易：只看余额，加减账户的余额数字</li><li>基于UTXO的交易：只记录交易过程，下一笔交易的输入必须是上一笔交易的输出</li></ul><p>双重支付问题：</p><p>把同一笔签名付给多个人：双花</p><p>分叉和最长链原则：</p><p><img src="/../imgs/1692716995496.png" alt="1692716995496"></p><p>区块链的读写权力：</p><p><img src="/../imgs/1692717248937.png" alt="1692717248937"></p><h1 id="第三节：区块链的骨骼和灵魂"><a href="#第三节：区块链的骨骼和灵魂" class="headerlink" title="第三节：区块链的骨骼和灵魂"></a>第三节：区块链的骨骼和灵魂</h1><h2 id="3-1-骨骼：加密算法"><a href="#3-1-骨骼：加密算法" class="headerlink" title="3.1 骨骼：加密算法"></a>3.1 骨骼：加密算法</h2><p><strong>非对称加密算法：私钥、公钥</strong></p><ul><li>一对两把密钥，分别用于加密解密（公开私有）</li><li>RSA算法：大整数分解；ECC算法：椭圆曲线</li><li>破解228比特的RSA密钥需要的能量可煮沸一茶匙的水，而破解228比特的ECC密钥需要的能量能煮沸地球上所有的水</li></ul><p><strong>哈希函数：梅克尔树、区块指针、比特币挖矿</strong></p><ul><li>任意长度消息压缩成固定长度的二进制串</li><li>SHA家族<ul><li>SHA-1（已被攻克）</li><li>SHA-256（比特币）</li><li>SHA-384</li><li>SHA-512</li></ul></li><li>MD4&#x2F;MD5（已被攻克）</li></ul><p><strong>私钥、公钥、地址、签名</strong></p><p><strong><img src="/1692718601904.png" alt="1692718601904"></strong></p><ul><li>私钥是随机选出的32 字节数字，通过非对称加密（椭圆曲线函数）产生一个公钥</li><li>公钥再通过哈希函数转化成比特币地址，接收转账等</li><li>公钥、地址、交易全网公开，但是背后关联的用户、身份信息完全匿名</li></ul><p><strong>梅克尔树</strong></p><ul><li>哈希算法：极大的输入唯一映射成极小的输出（验证ID）</li><li>将大量的交易数据通过层次化的哈希，递归生成根哈希值，记录在区块头中</li><li>快速归纳和校验区块数据的存在性和完整性</li></ul><h2 id="3-2-共识机制"><a href="#3-2-共识机制" class="headerlink" title="3.2 共识机制"></a>3.2 共识机制</h2><p>共识：</p><ul><li>对某事达成的共同看法</li><li>分布式的记账者群体对账本记录的交易达成一致</li><li>分布式的数据库节点对记录的数据达成一致，具备相同的状态</li></ul><p>比特币类共识机制的特点：</p><ul><li>随机性<ul><li>随机选记账者，提高作恶成本（连续作恶、大比例作恶）</li><li>随机数不可预测、不可被操控</li></ul></li><li>抗女巫攻击<ul><li>抵抗刷小号来提高被选中概率的作恶手法</li><li>增加门槛：计算力（工作量证明）、资源（权益证明）</li></ul></li><li>激励机制<ul><li>奖励诚实的参与者</li><li>包括对不诚实的作恶者的反激励机制</li></ul></li></ul><p><strong>工作量证明PoW</strong></p><ul><li>哈希函数：将任意长度的输入映射未为固定长度的输出，输出值不可预测<ul><li>特性：碰撞阻力，隐秘性，谜题友好</li></ul></li><li>找到结果需要高难度的计算，但是找到了正确结果后容易验证</li><li>比特币使用的哈希函数：SHA256</li><li><img src="/../imgs/1692805430518.png" alt="1692805430518"></li></ul><p><strong>权益证明PoS</strong></p><p><img src="/../imgs/1692805557174.png" alt="1692805557174"></p><p><strong>授权权益证明DPoS</strong></p><p><img src="/../imgs/1692805775501.png" alt="1692805775501"></p><p>以太坊：Ethereum(数字货币：ETH)</p><ul><li>建立在区块链技术上的去中心化应用平台</li><li>区块链2.0的代表</li></ul><p>主要特点：</p><ul><li><p>图灵完备</p><ul><li><p>指机器执行任何其他可编程计算机能够执行计算的能力。一切可计算的问题都能计算,这样的虚拟机或者编程语言就叫图灵完备。</p></li><li><p>图灵完备意味着你的语言能做到能用图灵机做到的所有事情,可以解决所有的可计算问题。</p></li><li><p>比特币的系统是图灵不完备的，而以太坊的智能合约系统是图灵完备的。</p></li><li><p>图灵完备的以太坊实现了可编程的区块链,支持 Javascript和 Solidity等语言编程,鲱建自己的应用。</p></li></ul></li><li><p>支持智能合约（机器式的契约信任）</p><ul><li><p>非智能合约的交互</p><ul><li>A和B达成交易,需要第三方协助执行条款,并且第三方来为交易进行信用背书</li></ul></li><li><p>使用智能合约的交互</p><ul><li><p>协议被全网记录，不需第三方协助，无人可以违背合约，无人可以伪造合约</p></li><li><p>开发者可以开发仼何应用,实现智能合约。以太坊提供平台支持智能合约的应用和部署</p></li></ul></li><li><p>智能合约的应用</p><ul><li><p>DApp：去中心化的app</p><ul><li>原理和普通app一致，除了去中心化</li><li>依靠以太坊的节点运作，不依赖任何的中心化服务器</li><li>去中心化自动运行程序</li></ul></li><li><p>DApp的服务器后台</p><ul><li>除了智能合约后台，DApp还需要数据库和UI交互界面</li><li>DApp：完整的智能合约+前端界面+后端数据库</li></ul></li><li><p>Cryptokitties(谜恋猫)</p></li></ul><p>  运行在以太坊网络的虚拟宠物游戏</p><p>  小猫特征随机变异,每一只猫独一无二,可以保有或出售</p><p>  交易额一度占据以太坊20%的流量,造成以太坊拥堵</p><ul><li><p>逐渐繁荣的DApp生态</p><p>在以太坊上目前已有超过2600种DApp运行,24h用户数达3万人</p><p>类别包括:游戏、去中心化金融、治理、存储、健康、媒体等等</p></li></ul></li></ul></li><li><p>定位于平台，可实现各种应用</p></li></ul><p><strong>基于以太坊发行代币</strong></p><ul><li>使用以太坊上的ERC20协议可发行 Token,该类 Token的交易会记录在以太坊区块链上,因此其安全性与可信度等同于以太币ETH</li><li>代币发行有开源的代码模板可以借鉴,技术实现门槛较低口</li></ul><p><strong>Initial Coin Offering(ICO，首次代币发行)</strong></p><ul><li><p>通过智能合约实现某代币和ETH或其他代币之间的兑换</p></li><li><p>性质类似于众筹,区别在于众筹的商品是“代币”，<strong>而代币可以在区块链上或交易所内快速流通</strong>，流通性近乎等于上市</p></li><li><p>2014年 Vitalik募集BTC就是第一次链上众筹</p></li></ul><p><strong>以太币ETH的作用</strong></p><ul><li>以太坊上用于支付交易手续费和运算服务的介质<ul><li>交易手续费: 同比特币等电子现金系统，记账者奖励</li><li>运算服务费: 支付费用来运算智能合约或者其他以太坊上的程序口</li></ul></li><li>Ico众筹中最常用的募资款项</li><li>加密货币交易市场中的主流交易对</li></ul><p>目前比较有发展前景的两个方向：</p><p><img src="/../imgs/1692030128675.png" alt="1692030128675"></p><p><img src="/../imgs/1692030178205.png" alt="1692030178205"></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>加密货币</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Selenium 4</title>
    <link href="/2022/12/01/UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <url>/2022/12/01/UI%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><strong>web自动化测试需求和挑战</strong></p><ul><li><p>属于E2E测试，是软件质量保证的最后一道防线</p></li><li><p>点点点：低效，复杂的场合无法测试</p></li><li><p>好的测试，不仅要模拟用户行为，还要记录、调试网页细节</p></li><li><p>优势：</p><ul><li>提速增效</li><li>解放双手</li><li>技能提示</li></ul></li><li><p>目前主流工具</p><ul><li><p>Cypress</p></li><li><p>Playwright</p></li><li><p>Selenium</p><p><img src="/../imgs/1667729144915.png" alt="1667729144915"></p></li></ul></li></ul><p>selenium优势：</p><ul><li>浏览器支持最多，兼容最好</li><li>支持多种编程语言</li><li>生态成熟、文档丰富</li><li>可以进行APP测试，事半功倍</li></ul><p><strong>本篇笔记基于selenium 4进行</strong></p><p><strong>Selenium自动化环境搭建</strong></p><p>一键搭建：</p><p>pip install webdriver-helper</p><p>webdriver-helper：</p><ul><li>自动获取浏览器的版本</li><li>自动下载浏览器驱动</li><li>自动创建和返回WebDriver对象</li></ul><h1 id="1-Selenium"><a href="#1-Selenium" class="headerlink" title="1. Selenium"></a>1. Selenium</h1><p>web自动化测试三板斧：</p><ul><li>定位元素</li><li>交互元素</li><li>进行断言</li></ul><p>如何判断页面元素是否嵌套在iframe里面：<a href="https://blog.csdn.net/lanniya152/article/details/124364417">https://blog.csdn.net/lanniya152/article/details/124364417</a></p><p><strong>常用方法</strong></p><p>1.get(url)浏览器访问url</p><p>2.set_window_size(宽,高)设置浏览器宽高</p><p>3.maximize_window()放大浏览器</p><p>4.quit()退出浏览器</p><p>5.back()后退</p><p>6.forward()前进</p><p>7.refresh() 刷新</p><h2 id="1-1-定位元素"><a href="#1-1-定位元素" class="headerlink" title="1.1. 定位元素"></a>1.1. 定位元素</h2><p>selenium提供了八大策略：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> selenium.webdriver.common.<span class="hljs-keyword">by</span> <span class="hljs-keyword">import</span> <span class="hljs-keyword">By</span><br></code></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ID</span> = <span class="hljs-string">&quot;id&quot;</span>以id属性进行定位<br><span class="hljs-attr">NAME</span> = <span class="hljs-string">&quot;name&quot;</span>以name属性进行定位<br><span class="hljs-attr">CLASS_NAME</span> = <span class="hljs-string">&quot;class name&quot;</span>以class属性进行定位<br><span class="hljs-attr">LINK_TEXT</span> = <span class="hljs-string">&quot;link text&quot;</span>以链接进行定位<br><span class="hljs-attr">PARTIAL_LINK_TEXT</span> = <span class="hljs-string">&quot;partial link text&quot;</span>以模糊链接进行定位<br><span class="hljs-attr">TAG_NAME</span> = <span class="hljs-string">&quot;tag name&quot;</span>以标签名进行定位<br><span class="hljs-attr">CSS_SELECTOR</span> = <span class="hljs-string">&quot;css selector&quot;</span>以css选择器进行定位<br><span class="hljs-attr">XPATH</span> = <span class="hljs-string">&quot;xpath&quot;</span>xpath定位<br></code></pre></td></tr></table></figure><p>使用定位策略：</p><p>1.driver.find_element_by_id()  # 这个方式已经被弃用了</p><p>2.driver.find_element(By.ID, ‘’)  # 推荐这种方式。4.0版本都使用这种方式</p><p>3.如果要一组多个元素，后面加s</p><p>driver.find_elements(By.ID, ‘’)  # 定位一组元素</p><p><strong>分组一：根据文本定位a标签</strong></p><ul><li>LINK_TEXT 精确定位</li><li>PARTIAL_LINK_TEXT   模糊定位</li></ul><p><strong>分组二：根据属性，定位任意元素</strong></p><ul><li>ID</li><li>NAME</li><li>CLASS_NAME</li><li>TAG_NAME</li></ul><p>对于同一个元素来讲，可以使用多种定位策略</p><p><strong>分组三：通用定位策略</strong></p><ul><li>CSS</li><li>XPath</li></ul><p>通用定位策略：可以定位到任意元素</p><p>分组二实际上是通过分组三的CSS完成定位的</p><h3 id="1-1-1-XPath"><a href="#1-1-1-XPath" class="headerlink" title="1.1.1 XPath"></a>1.1.1 XPath</h3><p><strong>XPath</strong>即为<a href="https://baike.baidu.com/item/XML?fromModule=lemma_inlink">XML</a>路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言。</p><ul><li>XPath是一种查询语言</li><li>支持逻辑运算、函数</li><li>实现非常强大的功能</li><li>可以用于APP自动化测试</li></ul><p>xpath的常用语法：</p><ul><li><p>通过绝对路径定位元素（不推荐使用）  &#x2F;</p></li><li><p>通过相对路径定位元素&#x2F;&#x2F;</p></li></ul><p>基本用法：<a href="https://blog.csdn.net/qq_50854790/article/details/123610184">https://blog.csdn.net/qq_50854790/article/details/123610184</a></p><p>1.XPath语法</p><p>​表示层级+属性</p><p>2.XPath函数</p><p>​函数是XPath的另一个魅力，常用的函数：</p><ul><li>text获取元素内的文本</li><li>contains  任意位置包含</li><li>starts-with  开头</li></ul><h3 id="1-1-2-CSS"><a href="#1-1-2-CSS" class="headerlink" title="1.1.2 CSS"></a>1.1.2 CSS</h3><p>CSS(Cascading Style Sheets)是一种语言，它被用来描述HTML 和XML 文档的表现。CSS定位比较灵活，一般情况下定位速度要比XPTAH要快。</p><h3 id="1-1-3-定位元素异常"><a href="#1-1-3-定位元素异常" class="headerlink" title="1.1.3 定位元素异常"></a>1.1.3 定位元素异常</h3><ol><li>元素不在当前页面</li><li>元素没有加载完成</li><li>页面中存在嵌套</li><li>元素不在html里面，可能是某个脚本生成的元素就无法定位</li></ol><p><strong>如何判断页面元素是否嵌套在iframe里面</strong></p><p><a href="https://blog.csdn.net/lanniya152/article/details/124364417">https://blog.csdn.net/lanniya152/article/details/124364417</a></p><p><strong>对于嵌套元素的定位</strong></p><p>1.找到对应元素位置最近的iframe开头的代码</p><p>2.定位iframe的位置</p><p>3.进入嵌套</p><p>c&#x3D;a.find_element_by_xpath(‘&#x2F;&#x2F;*[@id&#x3D;”anony-reg-new”]&#x2F;div&#x2F;div[1]&#x2F;iframe’)  # 定位嵌套iframe的位置 a.switch_to.frame(c)    # 進入嵌套</p><p>4.再定位对应元素的位置，完成指定的操作</p><p>5.退出嵌套</p><p>a.switch_to.default_content()   # 退出嵌套</p><h2 id="1-2-操控元素"><a href="#1-2-操控元素" class="headerlink" title="1.2 操控元素"></a>1.2 操控元素</h2><p><strong>常用方法</strong></p><ul><li>点击元素  click()方法</li><li>在元素中输入字符串，通常是对输入框这样的元素  send_keys()方法</li><li>获取元素包含的信息，比如文本内容，元素的属性  text()方法</li><li>清除元素内容  clear()方法</li></ul><p>1.点击元素</p><p>click()方法</p><p>当我们调用 WebElement 对象的 click 方法去点击 元素的时候， 浏览器接收到自动化命令，点击的是该元素的 <code>中心点</code> 位置 </p><p>2.输入字符</p><p>send_keys()方法</p><p>把输入框中已经有的内容清除掉，可以使用WebElement对象的clear方法</p><p>3.获取元素信息</p><ul><li><p>通过WebElement对象的 <code>text</code> 属性，可以获取元素 <code>展示在界面上的</code> 文本内容。</p><p>有时候，元素的文本内容没有展示在界面上，或者没有完全完全展示在界面上。 这时，用WebElement对象的text属性，获取文本内容，就会有问题。</p><p>出现这种情况，可以尝试使用 <code>element.get_attribute(&#39;innerText&#39;)</code> ，或者 <code>element.get_attribute(&#39;textContent&#39;)</code></p></li><li><p>通过WebElement对象的 get_attribute() 方法来获取元素的属性值</p><p>例如获取元素属性class的值：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">element = wd<span class="hljs-selector-class">.find_element</span>(By<span class="hljs-selector-class">.ID</span>, <span class="hljs-string">&#x27;input_name&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(element.get_attribute(<span class="hljs-string">&#x27;class&#x27;</span>)</span></span>)<br></code></pre></td></tr></table></figure></li><li><p>获取整个元素对应的html文本内容</p><p>可以使用 <code>element.get_attribute(&#39;outerHTML&#39;)</code></p><p>只是想获取某个元素 <code>内部</code> 的HTML文本内容，可以使用 <code>element.get_attribute(&#39;innerHTML&#39;)</code></p></li><li><p>获取输入框里面的文字</p><p>对于input输入框的元素，要获取里面的输入文本，用text属性是不行的，这时可以使用 <code>element.get_attribute(&#39;value&#39;)</code></p></li></ul><p><strong>ActionChains 类鼠标操作的常用方法：</strong></p><p>context_click() 右击</p><p>double_click() 双击</p><p>move_to_element() 模拟鼠标移到一个元素上（悬停）</p><p>click_and_hold(元素) 按下鼠标左键并保持</p><p>drag_and_drop() 拖动</p><p>drag_and_drop_by_offset()按坐标偏移拖动</p><p>使用：</p><p>1.引入ActionChains模块：from selenium.webdriver.common.action_chains import ActionChains</p><p>2.获取浏览器驱动browser&#x3D;webdriver.Chrome()</p><p>3.实例化ActionChainsactionchains&#x3D;ActionChains(browser)</p><p>4.定位页面元素locator&#x3D; browser.find_element_by_css_selector(‘span[name&#x3D;”tj_settingicon”]’)</p><p>5.对元素进行各种鼠标事件actionchains.context_click&#x2F;double_click&#x2F;move_to_element(locator).perform()</p><p><strong>键盘操作</strong></p><p>send_keys(Keys.BACK_SPACE) 删除键（BackSpace）</p><p>send_keys(Keys.SPACE) 空格键(Space)</p><p>send_keys(Keys.TAB) 制表键(Tab)</p><p>send_keys(Keys.ESCAPE) 回退键（Esc）</p><p>send_keys(Keys.ENTER) 回车键（Enter）</p><p>send_keys(Keys.CONTROL,’a’) 全选（Ctrl+A）</p><p>send_keys(Keys.CONTROL,’c’) 复制（Ctrl+C）</p><p>send_keys(Keys.CONTROL,’x’) 剪切（Ctrl+X）</p><p>send_keys(Keys.CONTROL,’v’) 粘贴（Ctrl+V）</p><p>send_keys(Keys.F1) 键盘F1</p><p>send_keys(Keys.Up) 键盘上移</p><h2 id="1-3-切换窗口"><a href="#1-3-切换窗口" class="headerlink" title="1.3 切换窗口"></a><strong>1.3 切换窗口</strong></h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">from</span> selenium.webdriver.common.<span class="hljs-keyword">by</span> <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> webdriver_helper <span class="hljs-keyword">import</span> get_webdriver<br><br><span class="hljs-keyword">with</span> get_webdriver() <span class="hljs-keyword">as</span> driver:<br>    driver.get(<span class="hljs-string">&#x27;https://www.baidu.com/&#x27;</span>)<br>    driver.find_element(By.XPATH, <span class="hljs-string">&#x27;//*[@id=&quot;s-top-left&quot;]/a[4]&#x27;</span>).click()<br>    <br>    <span class="hljs-comment"># 方法一：知道窗口ID,切换窗口（好像不能这么写，有待研究）</span><br>    <span class="hljs-built_in">print</span>(driver.window_handles)  <span class="hljs-comment"># 打印所有窗口的ID</span><br>    <span class="hljs-built_in">print</span>(driver.current_window_handle)  <span class="hljs-comment"># 获取当前窗口的ID</span><br>    driver.switch_to.window(<span class="hljs-string">&#x27;新窗口的ID&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 方法二：通过列表下标切换 </span><br>    driver.switch_to.window(driver.window_handles[<span class="hljs-number">-1</span>])  <span class="hljs-comment"># 切换到最新的窗口</span><br>    <span class="hljs-built_in">print</span>(driver.current_url)  <span class="hljs-comment"># 获取当前窗口的网址</span><br></code></pre></td></tr></table></figure><h2 id="1-4-弹窗处理"><a href="#1-4-弹窗处理" class="headerlink" title="1.4 弹窗处理"></a><strong>1.4 弹窗处理</strong></h2><p><strong>1.页面弹出框的操作</strong>（例如弹出登录网站的账号）</p><p> 页面弹出框是一个HTML页面的元素，只不过是由用户在页面的操作触发弹出的，所以执行这一类型的弹窗都是：</p><p>1.执行触发操作之后，等待弹窗出现；</p><p>2.再定位弹出框的元素并操作</p><p><strong>2.Alert、Confirm、Prompt弹出框操作</strong></p><p>警告提示框（alert）、确认消息框（confirm）、提示消息对话（prompt）</p><p>针对浏览器的弹出框我们一般使用以下方式：</p><p>1.使用switch_to方法切换到浏览器弹出框：alert &#x3D; driver.switch_to.alert</p><p>2.alert类提供了一系列操作方法：</p><ul><li>获取文本信息print（alert.text）</li><li>点击确认alert.accept()</li><li>点击取消alert.dismiss()</li><li>输入内容send_keys(）</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.<span class="hljs-keyword">by</span> <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">import</span> time<br><br>wd = webdriver.Chrome()<br>wd.implicitly_wait(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 隐式等待</span><br>wd.get(<span class="hljs-string">&#x27;https://cdn2.byhy.net/files/selenium/test4.html&#x27;</span>)<br><br>第一类：alert框<br><span class="hljs-comment"># 点击alert，弹出alert框</span><br>wd.find_element(By.XPATH, <span class="hljs-string">&#x27;//*[@id=&quot;b1&quot;]&#x27;</span>).click()<br><br><span class="hljs-comment"># 打印提示信息</span><br>alert = wd.switch_to.alert<br><span class="hljs-built_in">print</span>(alert.text)<br><br><span class="hljs-comment"># 点击确定</span><br>alert.accept()<br>time.sleep(<span class="hljs-number">5</span>)<br><br>第二类：confirm框<br><span class="hljs-comment"># 点击confirm，弹出confirm框</span><br>wd.find_element(By.XPATH, <span class="hljs-string">&#x27;//*[@id=&quot;b2&quot;]&#x27;</span>).click()<br><br>confirm = wd.switch_to.alert<br><br><span class="hljs-comment"># 打印提示信息</span><br><span class="hljs-built_in">print</span>(confirm.text)<br><br><span class="hljs-comment"># 点确定</span><br>confirm.accept()<br><span class="hljs-comment"># 点取消</span><br>confirm.dismiss()<br><br>第三类：prompt<br><span class="hljs-comment"># 点击confirm，弹出confirm框</span><br>wd.find_element(By.XPATH, <span class="hljs-string">&#x27;//*[@id=&quot;b3&quot;]&quot;]&#x27;</span>).click()<br><br><span class="hljs-comment"># 获取 alert 对象</span><br>alert = wd.switch_to.alert<br><br><span class="hljs-comment"># 打印 弹出框 提示信息</span><br><span class="hljs-built_in">print</span>(alert.text)<br><br><span class="hljs-comment"># 输入信息，并且点击 OK 按钮 提交</span><br>alert.send_keys(<span class="hljs-string">&#x27;web自动化 - selenium&#x27;</span>)<br>alert.accept()<br><br><span class="hljs-comment"># 点击 Cancel 按钮 取消</span><br>wd.find_element(By.ID, <span class="hljs-string">&#x27;b3&#x27;</span>).click()<br>alert = wd.switch_to.alert<br>alert.dismiss()<br><br></code></pre></td></tr></table></figure><p><strong>3.网页登录弹窗处理</strong></p><p>方法一：利用pynput库实现</p><p>方法二：直接利用url实现</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">driver.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;https://support:@Dating2001@nmm.masonvips.com/&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="1-5-下拉框select标签"><a href="#1-5-下拉框select标签" class="headerlink" title="1.5 下拉框select标签"></a>1.5 下拉框<strong>select标签</strong></h2><p>1.需要引入Select模块：from selenium.webdriver.support.ui import Select</p><p>2.定位select元素</p><p>3.再选择对应的选项</p><p>select_by_index() :通过索引定位，从0开始s</p><p>select_by_value() :通过value值定位</p><p>select_by_visible_text() :通过文本值定位</p><h2 id="1-6单选框radio-和复选框checkbox"><a href="#1-6单选框radio-和复选框checkbox" class="headerlink" title="1.6单选框radio 和复选框checkbox"></a>1.6<strong>单选框radio <strong>和复选框</strong>checkbox</strong></h2><p>直接定位单选框.click（）</p><p>复选框：选一个和全部选完</p><p><a href="https://blog.csdn.net/qq_44728587/article/details/122926002">https://blog.csdn.net/qq_44728587/article/details/122926002</a></p><h2 id="1-7-等待方式"><a href="#1-7-等待方式" class="headerlink" title="1.7 等待方式"></a>1.7 等待方式</h2><p>1.强制等待</p><p>使用方法：import time</p><p>from time import sleep</p><p>sleep(X)，等待X秒后，进行下一步操作。</p><p>第一种也是使用最简单的一种办法就是强制等待sleep(X)，强制让浏览器等待X秒，不管当前操作是否完成，是否可以进行下一步操作，都必须等X秒的时间。</p><p>缺点：不能准确把握需要等待的时间（有时操作还未完成，等待就结束了，导致报错；有时操作已经完成了，但等待时间还没有到，浪费时间），如果在用例中大量使用，会浪费不必要的等待时间，影响测试用例的执行效率。</p><p>优点：使用简单，可以在调试时使用</p><p>2.隐式等待</p><p>使用方法：implicitly_wait(X)，在X时间内，页面加载完成，进行下一步操作。</p><p>第二种方法是隐形等待，其设置了一个最长等待时间，如果在规定时间内网页加载完成（浏览器上没有转圈），则执行下一步，否则一直等到时间结束，然后执行下一步操作。</p><p>缺点：使用隐式等待，程序会一直等待整个页面加载完成，才会执行下一步操作；但有时候页面想要的元素早已经加载完成了，但是因为网页上个别元素还没有加载完成，仍要等到页面全部完成才能执行下一步，使用也不是很灵活。</p><p>优点：隐性等待对整个driver的周期都起作用，所以只要设置一次即可。</p><h1 id="2-单元测试框架pytest"><a href="#2-单元测试框架pytest" class="headerlink" title="2. 单元测试框架pytest"></a>2. 单元测试框架pytest</h1><h2 id="2-1-pytest基础"><a href="#2-1-pytest基础" class="headerlink" title="2.1 pytest基础"></a>2.1 pytest基础</h2><p>什么是测试框架？</p><p>对测试用例进行<strong>发现、组织、执行、记录、报告</strong>等管理操作，帮助测试人员更好的设计、开发自动化测试脚本</p><p>常见的python测试框架？</p><ul><li>UnitTest</li><li>pytest        pytest 是更加pythonic的测试框架，具有强烈风格特色</li><li>Robot Framework</li></ul><p>共同点：</p><p>1.标记和筛选用例</p><p>2.执行用例</p><p>3.记录测试过程</p><p>4.可以管理测试环境</p><p>5.生成测试报告</p><hr><p><strong>安装pytest</strong></p><p>pippython包管理工具</p><p>​pip install pytest</p><p>pip 安装第三方库报错最全解决方案</p><p><a href="https://lwebapp.com/zh/post/pip-install-error-guide">https://lwebapp.com/zh/post/pip-install-error-guide</a></p><p>使用方案五解决过：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">--index-url可以简写为-i</span><br>python -m pip install --index-url https://pypi.tuna.tsinghua.edu.cn/simple/ pandas<br></code></pre></td></tr></table></figure><p>除了官方源和清华镜像源</p><ul><li>清华：<code>https://pypi.tuna.tsinghua.edu.cn/simple/</code></li><li>官方：<code>https://pypi.org/</code></li></ul><p>还有些别的镜像源可以尝试</p><ul><li>阿里云：<code>https://mirrors.aliyun.com/pypi/simple/</code></li><li>豆瓣：<code>https://pypi.douban.com/simple/</code></li><li>北京外国语大学 <code>https://mirrors.bfsu.edu.cn/pypi/web/simple/</code></li></ul><p>pytest生态是由pytest本身和插件共同构成的：</p><ul><li>pytest：框架本体</li><li>pytest-html：生成html测试报告</li><li>pytest-xdist：并行化执行测试用例</li><li>pytest-rerunfailures：失败重跑</li><li>pytest-ordering：为用例排序</li><li>allure-pytest：生成allure测试报告</li></ul><hr><p><strong>启动pytest</strong></p><ul><li><p>命令行输入pytest（推荐使用）</p></li><li><p>python代码中执行pytest.main()</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-title">pytest</span>.main()<br></code></pre></td></tr></table></figure></li><li><p>pycharm提供 了testrunner（不建议使用）</p></li></ul><h2 id="2-2-编写用例"><a href="#2-2-编写用例" class="headerlink" title="2.2 编写用例"></a>2.2 编写用例</h2><h3 id="2-2-1-pytest测试用例的发现规则"><a href="#2-2-1-pytest测试用例的发现规则" class="headerlink" title="2.2.1 pytest测试用例的发现规则"></a>2.2.1 pytest测试用例的发现规则</h3><ol><li><p>从当前目录开始，遍历每一个目录</p></li><li><p>每个目录中搜索test_*.py  和  *__test.py，并导入</p></li><li><p>在导入的文件中，收集测试用例</p><ol><li><p>test开头的函数</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login</span>():<br>    pass<br></code></pre></td></tr></table></figure></li><li><p>Test开头类，及其test开头的方法（需要同时满足大小写才会当做测试用例）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Testapi:</span># <span class="hljs-symbol">Test</span>开头类<br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">test_login</span>(<span class="hljs-symbol">self</span>):# <span class="hljs-symbol">test</span>开头的方法 <br>        <span class="hljs-symbol">pass</span><br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">注意：<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Test:</span><br><span class="hljs-symbol">    <span class="hljs-symbol">def</span></span> <span class="hljs-symbol">__init__</span>(<span class="hljs-symbol">self</span>):  # 作为测试用例的<span class="hljs-symbol">class</span> 不可以有<span class="hljs-symbol">__init__</span>方法<br>        <span class="hljs-symbol">pass</span><br>    # 实例化之后自动执行<br><br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">test_login</span>(<span class="hljs-symbol">self</span>):<br>        <span class="hljs-symbol">pass</span><br></code></pre></td></tr></table></figure></li><li><p>unittest.TestCase的子类，及其test开头的方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> test(unittest.<span class="hljs-title class_">TestCase</span>):  <span class="hljs-comment"># 如果是unittest子类，对类名不做要求，依旧可以认定为测试用例</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        pass<br></code></pre></td></tr></table></figure></li></ol></li></ol><p>实践方法：</p><p>​1.创建test_开头的文件：test_api.py</p><p>​2.文件中，创建test_开头的函数：test_login</p><p>​3.函数中使用assert进行断言</p><h3 id="2-2-2-运行参数及其配置"><a href="#2-2-2-运行参数及其配置" class="headerlink" title="2.2.2 运行参数及其配置"></a>2.2.2 运行参数及其配置</h3><p>命令行输入pytest  -h查看全部</p><p>常用的配置：</p><ul><li>-v ：显示详细信息</li><li>-s ：关闭“输出捕获”</li><li>-n X：使用x个进程，并行化执行用例(一般电脑多少个CPU，X就等于多少)</li><li>-n auto：自动选择进程数 进行执行</li><li>–html&#x3D;Path：生成HTML测试报告，并保存在PATH路径（会附加生成一个CSS样式文件）<ul><li>命令行pytest –html&#x3D;report.html</li></ul></li><li>–self-contained-html：HTML自包含文件 (CSS内容直接保存在HTML文件，不新增CSS文件)<ul><li>命令行pytest –html&#x3D;report.html –self-contained-html</li></ul></li><li>–reruns X：测试用例失败之后，重试X次</li></ul><p><strong>配置化</strong></p><p> pytest.ini文件进行配置（创建一个pytest.ini文件，放在venv文件夹里面运行）</p><p>把上面的配置全部写在里面，运行时全部执行</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[pytest]</span><br><span class="hljs-attr">addopts</span> = -v -s -n <span class="hljs-number">1</span> --html=report.html<span class="hljs-comment"># 参数没有顺序</span><br></code></pre></td></tr></table></figure><h2 id="2-3-pytest-fixture"><a href="#2-3-pytest-fixture" class="headerlink" title="2.3 pytest.fixture"></a>2.3 pytest.fixture</h2><p>fixture也可以称之为软件测试的<strong>装置、夹具、脚手架</strong>，作用和目的：</p><ul><li>在测试执行之前，自动化准备相关的测试环境</li><li>在测试执行之后，将内容进行销毁</li></ul><p>初始化清除</p><h1 id="3-POM设计模式"><a href="#3-POM设计模式" class="headerlink" title="3. POM设计模式"></a>3. POM设计模式</h1><p><strong>Page Object Model</strong>：页面对象 设计模式</p><p>1.使用对象代表页面</p><p>2.使用对象的属性代表页面的元素</p><p>3.使用页面的方法代表页面的操作</p><p>定义过程：</p><p>1.定义BasePage（抽象类）</p><p>2.定义Page</p><p>3.定义元素的交互（对象方法）</p><p>使用过程：</p><p>1.打开页面，实例化Page</p><p>2.调用Page方法，完成交互</p><p>pytest解决了用例层面的问题,页面层面的问题没有解决.</p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UI自动化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-python版</title>
    <link href="/2022/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-Python%E7%89%88/"/>
    <url>/2022/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-Python%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-：导论"><a href="#第一章-：导论" class="headerlink" title="第一章 ：导论"></a>第一章 ：导论</h1><p><strong>算法概念</strong></p><p>算法（Algorithm）：一个计算过程，解决问题的方法。</p><blockquote><p>程序&#x3D;数据结构+算法</p></blockquote><p><strong>时间复杂度</strong></p><ul><li><p>用来评估算法运行时间的一个式子（单位）。</p></li><li><p>一般来说，时间复杂度高的算法比复杂度低的算法慢</p></li><li><p>常见的时间复杂度</p><p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n²logn)&lt;O(n³)</p></li><li><p>复杂问题的时间复杂度</p><p>O(n!)  O(2ⁿ)  O(nⁿ)</p><p>​</p></li></ul><p></p><p>O(n)</p><ul><li>O 可以理解为大约</li><li>n  可以理解为一个单位</li></ul><p><strong>如何简单快速的判断算法复杂度</strong></p><p>大多数简单情况：</p><ul><li>确定问题规模n</li><li>循环减半过程-&gt;logn</li><li>k层关于n的循环-&gt;n的k次方</li></ul><p>复杂情况：根据算法执行过程判断</p><p><strong>空间复杂度</strong></p><ul><li>用来评估算法内存占用大小的式子</li><li>空间复杂度的表示方式和时间复杂度完全一样<ul><li>算法使用了几个变量：O(1)</li><li>算法使用了长度为n的一卫列表：O(n)</li><li>算法使用了m行n列的二维列表：O(mn)</li></ul></li><li>‘空间换时间’ ：时间比空间重要</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h2><p><strong>递归的两个特点</strong></p><ul><li>调用自身</li><li>结束条件</li></ul><p><strong>递归实例</strong>：汉诺塔问题</p><p><img src="/../imgs/1673877309685.png" alt="1673877309685"></p><p><img src="/../imgs/1673877452210.png" alt="1673877452210"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">def hanoi(n, <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, c): # a经过b移动到c<br>    if n &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">hanoi</span>(n - <span class="hljs-number">1</span>, a, c, b)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;moving from %s to %s&#x27;</span> % (a, c))<br>        <span class="hljs-built_in">hanoi</span>(n - <span class="hljs-number">1</span>, b, a, c)<br><br><br><span class="hljs-built_in">hanoi</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="第二章：查找和排序"><a href="#第二章：查找和排序" class="headerlink" title="第二章：查找和排序"></a>第二章：查找和排序</h1><h2 id="2-1查找"><a href="#2-1查找" class="headerlink" title="2.1查找"></a>2.1查找</h2><ul><li>查找：在一些数据元素中，通过以一定的方法找出与给定关键字相同的数据元素的过程</li><li>列表查找（线性表查找）：从列表中查找指定元素<ul><li>输入：列表、待查找元素</li><li>元素下标（未找到元素时一般返回None或-1）</li></ul></li><li>内置列表查找函数：index（）    是顺序查找，二分查找必须是有序的（不能保证是排序的）</li></ul><p><strong>顺序查找</strong></p><p>也叫线性查找，从列表第一个元素开始，顺序进行搜索，直到找到元素或搜索到列表最后一个元素为止。</p><p>时间复杂度：O(n)</p><p><strong>二分查找</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def binary_search(li, val):<br>    left = <span class="hljs-number">0</span><br>    <span class="hljs-literal">right</span> = <span class="hljs-built_in">len</span>(li) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left &lt;= <span class="hljs-literal">right</span>:  <span class="hljs-comment"># 候选区有值</span><br>        <span class="hljs-keyword">mid</span> = (left + <span class="hljs-literal">right</span>)<span class="hljs-comment"> // 2  # 循环减半</span><br>        <span class="hljs-keyword">if</span> li[<span class="hljs-keyword">mid</span>] == val:<br>            <span class="hljs-literal">return</span> <span class="hljs-keyword">mid</span><br>        elif li[<span class="hljs-keyword">mid</span>] &gt; val:  <span class="hljs-comment"># 待查找的值在mid左侧</span><br>            <span class="hljs-literal">right</span> = <span class="hljs-keyword">mid</span> - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 待查找的值在mid右侧</span><br>            left = <span class="hljs-keyword">mid</span> + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-literal">return</span> None<br><br><br>li = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br>print(binary_search(li, <span class="hljs-number">3</span>))<br><span class="hljs-comment"># 结果为2</span><br></code></pre></td></tr></table></figure><p>时间复杂度：O(logn)</p><h2 id="2-2排序"><a href="#2-2排序" class="headerlink" title="2.2排序"></a>2.2排序</h2><ul><li>排序：将一组’无序’的记录序列调整为’有序’的记录序列</li><li>列表排序：将无序列表变为有序列表<ul><li>输入：列表</li><li>输出：有序列表</li></ul></li><li>升序与降序</li><li>内置排序函数sort()</li></ul><p>排序 LOW B三人组</p><ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li></ul><p>都是原地排序。</p><h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a><strong>1. 冒泡排序</strong>（Bubble Sort）</h3><ul><li>列表每两个相邻的数，如果前面比后面大，则交换这两个数。</li><li>一趟排序完成后，则无序区减少一个数，有序区增加一个数。</li><li>代码关键点：趟、无序区范围</li><li>时间复杂度：O(n²)</li></ul><p>初始代码：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">def bubble_sort(<span class="hljs-built_in">li</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-built_in">li</span>) - <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-built_in">li</span>) - i - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">li</span>[j] &gt; <span class="hljs-built_in">li</span>[j + <span class="hljs-number">1</span>]:<br>                <span class="hljs-built_in">li</span>[j], <span class="hljs-built_in">li</span>[j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">li</span>[j + <span class="hljs-number">1</span>], <span class="hljs-built_in">li</span>[j]<br></code></pre></td></tr></table></figure><p>优化后的代码：冒泡排序的一趟排序没有发生交换，则说明列表已经有序，可以直接结束算法。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs maxima">def bubble_sort(<span class="hljs-built_in">li</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-built_in">li</span>) - <span class="hljs-number">1</span>):<br>        exchange = False<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-built_in">li</span>) - i - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">li</span>[j] &gt; <span class="hljs-built_in">li</span>[j + <span class="hljs-number">1</span>]:  #  逆序就 &lt; <br>                <span class="hljs-built_in">li</span>[j], <span class="hljs-built_in">li</span>[j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">li</span>[j + <span class="hljs-number">1</span>], <span class="hljs-built_in">li</span>[j]<br>                exchange = True<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exchange:<br>            <span class="hljs-built_in">return</span><br><br><br><span class="hljs-built_in">li</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">18</span>]<br>bubble_sort(<span class="hljs-built_in">li</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">li</span>)<br></code></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a><strong>2. 选择排序</strong></h3><ul><li>一趟排序记录最小的数，放到第一个位置</li><li>再一趟排序记录列表无序区最小的数，放到第二个位置</li><li>算法关键点：有序区和无序区、无序区最小数的位置</li><li>时间复杂度：O(n²)</li></ul><p>初步想法代码：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">select_sort_simple</span>(li):<br>    li_new = []<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(li)):  # 复杂度<span class="hljs-built_in">O</span>(n)<br>        min_val = <span class="hljs-built_in">min</span>(li)  # 复杂度<span class="hljs-built_in">O</span>(n)<br>        li_new.<span class="hljs-built_in">append</span>(min_val)<br>        li.<span class="hljs-built_in">remove</span>(min_val)  # 复杂度<span class="hljs-built_in">O</span>(n)<br>    return li_new<br>#  整体代码复杂度<span class="hljs-built_in">O</span>(n²)<br></code></pre></td></tr></table></figure><p>不是原地排序，需要开辟新的列表。需要尽量考虑原地排序，减少复杂度。</p><p>优化代码：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs maxima">def select_sort(<span class="hljs-built_in">li</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-built_in">li</span>) - <span class="hljs-number">1</span>):  # i是第几趟<br>        min_loc = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, len(<span class="hljs-built_in">li</span>)):  # 然后把最小的放前面<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">li</span>[j] &lt; <span class="hljs-built_in">li</span>[min_loc]:<br>                min_loc = j<br>        <span class="hljs-keyword">if</span> min_loc != i:<br>            <span class="hljs-built_in">li</span>[i], <span class="hljs-built_in">li</span>[min_loc] = <span class="hljs-built_in">li</span>[min_loc], <span class="hljs-built_in">li</span>[i]<br>    <span class="hljs-built_in">return</span> <span class="hljs-built_in">li</span><br><br><br><span class="hljs-built_in">li</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">18</span>]<br><span class="hljs-built_in">print</span>(select_sort(<span class="hljs-built_in">li</span>))<br></code></pre></td></tr></table></figure><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a><strong>3. 插入排序</strong></h3><ul><li>初始时手里（有序区）一张牌</li><li>每次从无序区摸一张牌，插入到手里已有牌的正确位置</li><li>时间复杂度：O(n²)</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">def <span class="hljs-keyword">insert_sort(li):</span><br><span class="hljs-keyword"></span>    for i in range(len(li) - <span class="hljs-number">1</span>):<br>        tmp = li[i]<br>        <span class="hljs-keyword">j </span>= i - <span class="hljs-number">1</span>  <span class="hljs-comment"># j指手里的牌的下标</span><br>        while li[<span class="hljs-keyword">j] </span>&gt; tmp <span class="hljs-keyword">and </span><span class="hljs-keyword">j </span>&gt;= <span class="hljs-number">0</span>:<br>            li[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>] = li[<span class="hljs-keyword">j]</span><br><span class="hljs-keyword"></span>            <span class="hljs-keyword">j </span>-= <span class="hljs-number">1</span><br>        li[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>] = tmp<br><br><br>li = [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>]<br><span class="hljs-keyword">insert_sort(li)</span><br><span class="hljs-keyword"></span>print(li)<br></code></pre></td></tr></table></figure><p>排序NB三人组</p><ul><li>快速排序</li><li>堆排序</li><li>归并排序</li></ul><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a><strong>4. 快速排序</strong></h3><p>快速排序思路：</p><ul><li><p>取一个元素（第一个元素），是元素P归位</p></li><li><p>列表被P分成两部分，左边都比P小，右边都比P大</p></li><li><p>递归完成排序</p></li></ul><p>快速排序的效率问题：</p><ul><li>快速排序的时间复杂度  O(nlogn)</li></ul><p>快速排序的问题：</p><ul><li>最坏情况  （一个倒序的列表的时间复杂度是O（n²））</li><li>递归</li></ul><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nsis">def quick_sort(li, <span class="hljs-literal">left</span>, <span class="hljs-literal">right</span>):<br>    if <span class="hljs-literal">left</span> &lt; <span class="hljs-literal">right</span>: <span class="hljs-comment"># 至少两个元素</span><br>        mid = partition(li, <span class="hljs-literal">left</span>, <span class="hljs-literal">right</span>)<br>        quick_sort(li, <span class="hljs-literal">left</span>, mid - <span class="hljs-number">1</span>)<br>        quick_sort(li, mid + <span class="hljs-number">1</span>, <span class="hljs-literal">right</span>)<br>        <span class="hljs-keyword">return</span> li<br><br>def partition(li, <span class="hljs-literal">left</span>, <span class="hljs-literal">right</span>):<br>    tmp = li[<span class="hljs-literal">left</span>]<br>    while <span class="hljs-literal">left</span> &lt; <span class="hljs-literal">right</span>:<br>        while li[<span class="hljs-literal">right</span>] &gt;= tmp and <span class="hljs-literal">left</span> &lt; <span class="hljs-literal">right</span>:  <span class="hljs-comment"># 从右边找比tmp小的数</span><br>            <span class="hljs-literal">right</span> -= <span class="hljs-number">1</span>  <span class="hljs-comment"># 左走一步</span><br>        li[<span class="hljs-literal">left</span>] = li[<span class="hljs-literal">right</span>]  <span class="hljs-comment"># 把右边比tmp小的数放到左边</span><br>        while li[<span class="hljs-literal">left</span>] &lt;= tmp and <span class="hljs-literal">left</span> &lt; <span class="hljs-literal">right</span>:<br>            <span class="hljs-literal">left</span> += <span class="hljs-number">1</span><br>        li[<span class="hljs-literal">right</span>] = li[<span class="hljs-literal">left</span>]  <span class="hljs-comment"># 把左边的值写到右边</span><br>    li[<span class="hljs-literal">left</span>] = tmp  <span class="hljs-comment"># 把tmp归位</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">left</span><br><br><br>li = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br>s = quick_sort(li,<span class="hljs-number">0</span>,len(li)-<span class="hljs-number">1</span>)<br><span class="hljs-literal">print</span>(s)<br></code></pre></td></tr></table></figure><h3 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5. 堆排序"></a><strong>5. 堆排序</strong></h3><p>堆：一种特殊的完全二叉树结构</p><ul><li>大根堆：一颗完全二叉树，满足任一节点都比其孩子节点大</li><li>小根堆：一颗完全二叉树，满足任一节点都比其他孩子节点小</li></ul><p>堆的向下调整：当根节点的左右子树都是堆时，可以通过一次向下的调整来将其变成一个堆</p><p>堆排序过程：</p><p>1.建立堆</p><p>2.得到堆顶元素，为最大元素</p><p>3.去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序</p><p>4.堆顶元素为第二大元素</p><p>5.重复步骤3，直到堆边空</p><p>堆排序–topk问题</p><p>现在有n个数，设计算法得到前k大的数。（k&lt;n）</p><p>解决思路：</p><p>1.排序后切片  O(nlogn)</p><p>2.排序LOWB三人组  O(kn)</p><p>3.堆排序思路  O(nlogk)</p><h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h3><h3 id="7-其他排序"><a href="#7-其他排序" class="headerlink" title="7. 其他排序"></a>7. 其他排序</h3><ul><li>希尔排序</li><li>计数排序</li><li>基数排序</li></ul><h1 id="第三章：数据结构"><a href="#第三章：数据结构" class="headerlink" title="第三章：数据结构"></a>第三章：数据结构</h1><p>数据结构：数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。简单来说，数据结构就是设计数据以何种方式组织并存储在计算机中。</p><p>比如：python入门时的列表、字典、集合等都是一种数据结构。</p><p><strong>程序 &#x3D; 数据结构 + 算法</strong></p><p>数据结构的分类(按照其逻辑结构分)：</p><ul><li>线性结构：数据结构中的元素存在一对一的相互关系</li><li>树结构：数据结构中的元素存在一对多的相互关系</li><li>图结构：数据结构中的元素存在多对多的相互关系</li></ul><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h2 id="3-1-列表"><a href="#3-1-列表" class="headerlink" title="3.1 列表"></a>3.1 列表</h2><p>其他语言称为数组，是一种基本数据类型。</p><p>数组和列表的区别：</p><p>1.数组元素类型要相同</p><p>2.数组长度要固定</p><hr><ul><li>列表是顺序存储的？</li><li>列表的基本操作？<ul><li>按下标查找  li[2]</li><li>获取指定元素的索引  li.index(‘2’)</li><li>插入元素 li.append(‘2’)  li.extend(‘2’)  li.insert(2,’2’)</li><li>删除元素  li.remove(‘2’)  li.pop(2)</li></ul></li><li>这些操作的时间复杂度是多少？<ul><li>append是O(1)</li><li>insert、pop、remove都是是O(n)</li></ul></li></ul><p>扩展：python的列表是如何实现的？</p><h2 id="3-2-栈-Stack"><a href="#3-2-栈-Stack" class="headerlink" title="3.2 栈(Stack)"></a>3.2 栈(Stack)</h2><p>栈（Stack）是一种数据集合，可以理解为只能在一端进行插入或删除操作的列表。</p><p>栈的特点：后进先出LIFO(last-in,first-out)</p><p>栈的概念：栈顶、栈底</p><p>栈的基本操作：</p><ul><li>进栈（压栈）：push</li><li>出栈：pop</li><li>取栈顶：gettop</li></ul><p><img src="/../imgs/1680333686740.png" alt="1680333686740"></p><hr><p>使用一般的列表结构即可实现栈：</p><ul><li>进栈：li.append()</li><li>出栈：li.pop()</li><li>取栈顶：li[-1]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.stack = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, element</span>):  <span class="hljs-comment"># 进栈</span><br>        <span class="hljs-keyword">return</span> self.stack.append(element)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 出栈</span><br>        <span class="hljs-keyword">return</span> self.stack.pop(-<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gettop</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 去栈顶</span><br>        <span class="hljs-keyword">if</span> self.stack != []:<br>            <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.stack<br><br><br>stack = Stack()<br>stack.push(<span class="hljs-number">1</span>)<br>stack.push(<span class="hljs-number">2</span>)<br>stack.push(<span class="hljs-number">3</span>)<br><span class="hljs-comment"># print(stack.pop())</span><br><span class="hljs-built_in">print</span>(stack.get())<br></code></pre></td></tr></table></figure><hr><p><strong>栈的经典应用</strong> – <strong>括号匹配问题</strong></p><p>括号匹配问题：给一个字符串，其中包括小括号、中括号、大括号，求该字符串中的括号是否匹配。</p><p>例如：（[{}]）是匹配的。      ｛()] 是不匹配的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">brack_match</span>(<span class="hljs-params">s</span>):<br>    li = []<br>    dic = &#123;<span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br>        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> &#123;<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>&#125;:<br>            li.append(i)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(li) == <span class="hljs-number">0</span>: <span class="hljs-comment"># 需要先判断&#x27;)&#x27;这种类似情况</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">elif</span> dic[i] == li[-<span class="hljs-number">1</span>]: <span class="hljs-comment"># 再判断是不是和前一个匹配</span><br>                li.pop()<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># dic[i] != li[-1]</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># 判断&#x27;(&#x27;这种类似情况</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(li) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="3-3-队列-Queue"><a href="#3-3-队列-Queue" class="headerlink" title="3.3 队列(Queue)"></a>3.3 队列(Queue)</h2><p>队列（Queue）是一个数据集合，仅允许在列表的一端进行插入，另一端进行删除。</p><ul><li>进行插入的一端称为队尾（rear），插入动作称为进队或入队</li><li>进行删除的一端称为队头（front），删除动作称为出队</li><li>队列的性质：先进先出（first-in，first-out）</li></ul><p><img src="/../imgs/1675586589007.png" alt="1675586589007"></p><p><strong>队列的实现方式 – 环形队列</strong></p><p><img src="/../imgs/1675589944446.png" alt="1675589944446"></p><p>环形对列：当指针front &#x3D;&#x3D; maxsize - 1时，再前进一个位置就自动到0。</p><ul><li>队首指针前进1：front &#x3D; (front+1) % maxsize</li><li>队尾指针前进1：rear &#x3D; (rear+1) % maxsize</li><li>队空条件：rear &#x3D;&#x3D; front</li><li>队满条件： （rear+1） % maxsize &#x3D;&#x3D; front</li></ul><p>自己写代码实现环形队列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, size=<span class="hljs-number">100</span></span>):<br>        self.queue = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]<br>        self.size = size<br>        self.rear = <span class="hljs-number">0</span>  <span class="hljs-comment"># 队尾指针</span><br>        self.front = <span class="hljs-number">0</span>  <span class="hljs-comment"># 队首指针</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, element</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_filled():<br>            self.rear = (self.rear + <span class="hljs-number">1</span>) % self.size<br>            self.queue[self.rear] = element<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;queue is filled&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_empty():<br>            self.front = (self.front + <span class="hljs-number">1</span>) % self.size<br>            <span class="hljs-keyword">return</span> self.queue[self.front]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;queue is empty&#x27;</span>)<br><br>    <span class="hljs-comment"># 判断队空</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.rear == self.front<br><br>    <span class="hljs-comment"># 判断队满</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_filled</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (self.rear + <span class="hljs-number">1</span>) % self.size == self.front<br><br><br>q = Queue(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    q.push(i)<br><br><span class="hljs-built_in">print</span>(q.pop())<br>q.push(<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(q.is_filled())<br></code></pre></td></tr></table></figure><p><strong>双向队列</strong></p><p>双向队列的两端都支持进队和出队操作</p><ul><li>队首进队</li><li>队首出队</li><li>队尾进队</li><li>队尾出队</li></ul><p><img src="/../imgs/1675612543077.png" alt="1675612543077"></p><p>python中内置的队列模块</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> collections import deque<br><br><span class="hljs-attribute">q</span> = deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>)<br><span class="hljs-comment"># 单向队列</span><br><span class="hljs-attribute">q</span>.append(<span class="hljs-number">5</span>)  # 队尾进队<br><span class="hljs-attribute">q</span>.popleft()  # 队首进队<br><br><span class="hljs-comment"># 用于双向队列</span><br><span class="hljs-attribute">q</span>.appendleft(<span class="hljs-number">7</span>)  # 队首进队<br><span class="hljs-attribute">q</span>.pop()  # 队尾出队<br></code></pre></td></tr></table></figure><p>可以用队列大致实现linux中tail命令（输出最后几行文本）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tail</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-comment">#  主要依赖python中的队列，队满之后再入队，前面就出队，所以全部入队后就剩最后n个数据</span><br>        q = deque(f, n)<br>        <span class="hljs-keyword">return</span> q<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tail(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><h4 id="方法一：栈-–-深度优先搜索-DFS"><a href="#方法一：栈-–-深度优先搜索-DFS" class="headerlink" title="方法一：栈 – 深度优先搜索 DFS"></a>方法一：栈 – 深度优先搜索 DFS</h4><ul><li>回溯法</li><li>思路：从一个节点开始，任意找下一个能走的点，当找不到能走的点时，退回上一个点寻找是否有其他方向的点。</li><li>使用栈存储当前路径</li></ul><p><img src="/../imgs/1682264942618.png" alt="1682264942618"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python">maze = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>]<br><br>dirs = [<br>    <span class="hljs-keyword">lambda</span> x, y: (x - <span class="hljs-number">1</span>, y),<br>    <span class="hljs-keyword">lambda</span> x, y: (x, y + <span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">lambda</span> x, y: (x + <span class="hljs-number">1</span>, y),<br>    <span class="hljs-keyword">lambda</span> x, y: (x, y - <span class="hljs-number">1</span>)<br>]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maze_path</span>(<span class="hljs-params">x1, y1, x2, y2</span>):<br>    stack = []<br>    stack.append((x1, y1))<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span>:<br>        curNode = stack[-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 当前节点</span><br>        <span class="hljs-comment"># 走到终点了</span><br>        <span class="hljs-keyword">if</span> curNode[<span class="hljs-number">0</span>] == x2 <span class="hljs-keyword">and</span> curNode[<span class="hljs-number">1</span>] == y2:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> stack:<br>                <span class="hljs-built_in">print</span>(i)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-comment"># x,y四个方向：上右下左 (x-1,y);(x,y+1);(x+1,y);(x,y-1);</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">dir</span> <span class="hljs-keyword">in</span> dirs:<br>            nextNode = <span class="hljs-built_in">dir</span>(curNode[<span class="hljs-number">0</span>], curNode[<span class="hljs-number">1</span>])<br>            <span class="hljs-comment"># 如果下个节点能走</span><br>            <span class="hljs-keyword">if</span> maze[nextNode[<span class="hljs-number">0</span>]][nextNode[<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>:<br>                stack.append(nextNode)<br>                maze[nextNode[<span class="hljs-number">0</span>]][nextNode[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>  <span class="hljs-comment"># 标记走过的点为2，有没有必要后面再想</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            maze[nextNode[<span class="hljs-number">0</span>]][nextNode[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span><br>            stack.pop()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;没有路！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br>maze_path(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>​</p><h4 id="方法二：队列-–-广度优先搜索-BFS"><a href="#方法二：队列-–-广度优先搜索-BFS" class="headerlink" title="方法二：队列 – 广度优先搜索 BFS"></a>方法二：队列 – 广度优先搜索 BFS</h4><ul><li>思路：从一个节点开始，寻找所有接下来能继续走的点，继续不断寻找，知道找到出口</li><li>使用队列存储当前正在考虑的节点</li></ul><p><img src="/../imgs/1683793807805.png" alt="1683793807805"></p><p>还需要一个队列来往回找走到终点的的路径，该路径为最短路径</p><table><thead><tr><th align="center">出队序列下标</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th></tr></thead><tbody><tr><td align="center">出队序列</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td></tr><tr><td align="center">让它来的下标</td><td align="center">-1</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">2</td><td align="center">3</td><td align="center">4</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>maze = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>]<br><br>dirs = [<br>    <span class="hljs-keyword">lambda</span> x, y: (x - <span class="hljs-number">1</span>, y),<br>    <span class="hljs-keyword">lambda</span> x, y: (x, y + <span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">lambda</span> x, y: (x + <span class="hljs-number">1</span>, y),<br>    <span class="hljs-keyword">lambda</span> x, y: (x, y - <span class="hljs-number">1</span>)<br>]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_r</span>(<span class="hljs-params">path</span>):<br>    curNode = path[-<span class="hljs-number">1</span>]<br>    realpath = []<br>    <span class="hljs-keyword">while</span> curNode[<span class="hljs-number">2</span>] != -<span class="hljs-number">1</span>:<br>        realpath.append(curNode[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])<br>        curNode = path[curNode[<span class="hljs-number">2</span>]]<br>    realpath.append(curNode[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])  <span class="hljs-comment"># 起点</span><br>    realpath.reverse()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> realpath:<br>        <span class="hljs-built_in">print</span>(i)<br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maze_path_queue</span>(<span class="hljs-params">x1, y1, x2, y2</span>):<br>    queue = deque()<br>    queue.append((x1, y1, -<span class="hljs-number">1</span>))<br>    path = []<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>:<br>        curNode = queue.popleft()  <span class="hljs-comment"># 当前节点出队</span><br>        path.append(curNode)<br>        <span class="hljs-comment"># 判断终点</span><br>        <span class="hljs-keyword">if</span> curNode[<span class="hljs-number">0</span>] == x2 <span class="hljs-keyword">and</span> curNode[<span class="hljs-number">1</span>] == y2:<br>            print_r(path)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-comment"># 后面节点入队</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">dir</span> <span class="hljs-keyword">in</span> dirs:<br>            nextNode = <span class="hljs-built_in">dir</span>(curNode[<span class="hljs-number">0</span>], curNode[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">if</span> maze[nextNode[<span class="hljs-number">0</span>]][nextNode[<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>:<br>                queue.append((nextNode[<span class="hljs-number">0</span>], nextNode[<span class="hljs-number">1</span>], <span class="hljs-built_in">len</span>(path) - <span class="hljs-number">1</span>))  <span class="hljs-comment"># 后续节点进队，记录那个节点带它来的</span><br>                maze[nextNode[<span class="hljs-number">0</span>]][nextNode[<span class="hljs-number">1</span>]] = <span class="hljs-number">2</span>  <span class="hljs-comment"># 标记为已经走过</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;没有路&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br>maze_path_queue(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h2 id="3-4-链表"><a href="#3-4-链表" class="headerlink" title="3.4 链表"></a>3.4 链表</h2><p>链表是由一系列节点组成的元素集合。每个节点包含两部分，数据域item和指向下一个节点的指针next。通过节点之间的相互连接，最终串联成一个链表。</p><p><strong>创建链表</strong></p><ul><li><p>头插法</p><p><img src="/../imgs/1683873719103.png" alt="1683873719103"></p></li><li><p>尾插法</p><p><img src="/../imgs/1683873738638.png" alt="1683873738638"></p></li></ul><p><strong>链表与顺序表(列表&#x2F;数组)</strong></p><ul><li>链表在插入和删除的操作明显快于顺序表</li><li>链表的内存可以更灵活的分配<ul><li>可以尝试利用链表重新实现栈和队列</li></ul></li><li>链表这种链式存储的数据结构对数和图结构有很大的启发性</li></ul><h2 id="3-5-哈希表-Hash-Table"><a href="#3-5-哈希表-Hash-Table" class="headerlink" title="3.5 哈希表(Hash Table)"></a>3.5 哈希表(Hash Table)</h2><p>通过哈希函数来计算数据存储位置的数据结构，通常支持如下操作：</p><ul><li>insert(key,value): 插入键值对</li><li>get(key): 如果存在键为key的键值对则返回value，否则返回空值</li><li>delete(key): 删除键为key的键值对</li></ul><hr><p><img src="/../imgs/1683877448486.png" alt="1683877448486"></p><p><strong>直接寻址表缺点</strong></p><ul><li>当域U很大时，需要消耗大量内存，很不实际</li><li>如果域很大，而实际出现的key很少，则大量空间被浪费</li><li>无法处理关键字不是数字的情况</li></ul><p><strong>哈希</strong></p><p>直接寻址表：key为k的元素放到k位置上</p><p>改进直接寻址表：哈希（Hashing）</p><ul><li>构建大小为m的寻址表T</li><li>key为k的元素放到h(k)上</li><li>h(k)时一个函数，其将域U映射到表T[0,1,…,m-1]</li></ul><p>哈希表 (又称散列表)，是一种线性表的存储结构。哈希表由一个<strong>直接寻址表</strong>和<strong>哈希函数</strong>组成，哈希函数h(k)将元素关键字k作为自变量，返回元素的存储下标。</p><p>假设有一个长度为7的哈希表，哈希函数h(k) &#x3D; k%7。元素集合{14，22，3，5}的存储方式如下图。</p><p><img src="/../imgs/1683877878041.png" alt="1683877878041"></p><hr><p><strong>哈希冲突</strong></p><p>由于哈希表的大小是有限的，而要存储的值的总数量是无线的，因此对于任何哈希函数，都会出现两个不同元素映射到同一个位置上的情况，这种情况叫做哈希冲突。</p><p>例如：h(k)&#x3D;k%7，h(0) &#x3D; h(7) &#x3D; h(14) &#x3D; … </p><p>解决哈希冲突：</p><ul><li><p>开放寻址法：如果哈希函数返回的位置已经有值，则可以向后探查新的位置来存储这个值。</p><ul><li>线性探查：如果位置i被占用，则探查i+1，i+2，…</li><li>二次探查：如果位置i被占用，则探查i+1²，i-1²，i+2²，i-2²…</li><li>二度哈希：有n个哈希函数，当使用第一个哈希函数h1发生冲突时，则尝试使用h2，h3…</li></ul></li><li><p>拉链法（比较常用的方法）</p><p>哈希表每个位置都连接一个链表，当冲突发生时，冲突的元素将被加到该位置链表的最后。</p><p><img src="/../imgs/1683878880346.png" alt="1683878880346"></p></li></ul><p>常见的哈希函数</p><ul><li><p>除法哈希法(比较常见的)</p><p>h(k) &#x3D; k % m</p></li><li><p>乘法哈希法</p></li><li><p>全域哈希法</p></li></ul><hr><p><strong>哈希表的应用</strong> </p><ul><li><p>集合{} 和 字典{}</p><p><img src="/../imgs/1683968841075.png" alt="1683968841075"></p></li><li><p>md5算法</p><p><img src="/../imgs/1683968875380.png" alt="1683968875380"></p><p><img src="/../imgs/1683968934570.png" alt="1683968934570"></p></li><li><p>SHA2算法</p><p><img src="/../imgs/1683969090169.png" alt="1683969090169"></p></li></ul><p>​</p><h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><h2 id="3-6-树与二叉树"><a href="#3-6-树与二叉树" class="headerlink" title="3.6 树与二叉树"></a>3.6 树与二叉树</h2><ul><li>树是一种数据结构     比如：目录结构</li><li>树是一种可以递归定义的数据结构</li><li>树是由n个节点组成的集合<ul><li>如果n&#x3D;0，那这是一颗空树</li><li>如果n&gt;0，那存在一个节点作为树的根节点，其他节点又可以分为m个集合，每个集合本身又是一棵树</li></ul></li></ul><p><img src="/../imgs/1684482649695.png" alt="1684482649695"></p><p><strong>相关概念</strong></p><ul><li>根节点(A)、叶子节点(不能分叉的节点，BCHIPQKLMN都是叶子节点)</li><li>树的深度（高度）（最深有几层，此处为4层）</li><li>树的度：所有节点最大的度，为该树的度，例如该图的树的度为6<ul><li>节点的度：看分了几个叉，例如节点E的度是2，节点F的度是3</li></ul></li><li>孩子节点、父节点：节点之间的关系，例如A是B的父节点，B是A的子节点</li><li>子树：EIJPQ就是一个子树</li></ul><h3 id="3-6-1-二叉树"><a href="#3-6-1-二叉树" class="headerlink" title="3.6.1 二叉树"></a><strong>3.6.1 二叉树</strong></h3><ul><li>度不超过2的树</li><li>每个节点最多有两个孩子节点</li><li>两个孩子节点被区分为左孩子节点和右孩子节点</li></ul><p>解题过程中两种最主要的形式：</p><p><strong>满二叉树</strong>：一个二叉树，如果每一层的节点数都达到最大值，则这个二叉树是满二叉树（图a）；深度为k，有2^k-1个节点的二叉树。</p><p><strong>完全二叉树</strong>：叶节点只能出现在最下层和次下层，并且最下面一层的节点都集中在该层最左边的若干位置的二叉树。(可以理解为最下一层可以不满，但是，最下层的节点必须优先排左边，例如图b)；若最底层为h层，则该层包含1~2^(h-1)个节点。</p><p>堆就是一个完全二叉树，同时保证父子节点的顺序关系。</p><p><img src="/../imgs/1678018167762.png" alt="1678018167762"></p><p><strong>二叉搜索树</strong></p><p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p></li><li><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p></li><li><p>它的左、右子树也分别为二叉排序树</p><p><img src="/../imgs/1684564655291.png" alt="1684564655291"></p></li></ul><p><strong>平衡二叉搜索树</strong></p><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p><img src="/../imgs/1684564713122.png" alt="1684564713122"></p><p><strong>二叉树的存储方式（表示方式）</strong></p><ul><li><p>链式存储方式（指针）</p><p>将二叉树的节点定义为一个对象，节点之间通过类似链表的连接方式来连接</p></li><li><p>顺序存储方式（数组）</p><p>1.通过父节点找孩子节点：</p><p><img src="/../imgs/1678018569644.png" alt="1678018569644"></p><p>2.通过孩子节点找父节点 ： i &#x3D; (i - 1) &#x2F;&#x2F; 2</p></li></ul><p><strong>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</strong></p><p><strong>二叉树的遍历</strong></p><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ol><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，只要大家记住 前中后序指的就是中间节点的位置就可以了。</p><p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>大家可以对着如下图，看看自己理解的前后中序有没有问题。</p><p><img src="/../imgs/20200806191109896.png" alt="img"></p><p><strong>二叉树的定义</strong>（链式存储）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p><strong>前后中序的递归写法三要素</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><br><span class="hljs-comment"># 前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution1</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>):<br>        res = []  <span class="hljs-comment"># 保存结果</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">traversal</span>(<span class="hljs-params">root: TreeNode</span>):<br>            <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br>            res.append(root.value)  <span class="hljs-comment"># 前序</span><br>            traversal(root.left)  <span class="hljs-comment"># 左</span><br>            traversal(root.right)  <span class="hljs-comment"># 右</span><br><br>        traversal(root)<br>        <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-comment"># 中序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution2</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>):<br>        res = []  <span class="hljs-comment"># 保存结果</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">traversal</span>(<span class="hljs-params">root: TreeNode</span>):<br>            <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br><br>            traversal(root.left)  <span class="hljs-comment"># 左</span><br>            res.append(root.value)  <span class="hljs-comment"># 中序</span><br>            traversal(root.right)  <span class="hljs-comment"># 右</span><br><br>        traversal(root)<br>        <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-comment"># 后序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution3</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>):<br>        res = []  <span class="hljs-comment"># 保存结果</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">traversal</span>(<span class="hljs-params">root: TreeNode</span>):<br>            <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br><br>            traversal(root.left)  <span class="hljs-comment"># 左</span><br>            traversal(root.right)  <span class="hljs-comment"># 右</span><br>            res.append(root.value)  <span class="hljs-comment"># 后序</span><br><br>        traversal(root)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第四章：算法进阶"><a href="#第四章：算法进阶" class="headerlink" title="第四章：算法进阶"></a>第四章：算法进阶</h1><h2 id="4-1-贪心算法"><a href="#4-1-贪心算法" class="headerlink" title="4.1 贪心算法"></a>4.1 贪心算法</h2><p>局部最优 –&gt; 全局最优</p><ul><li>又称贪婪算法，是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的是在某种意义上的局部最优解。</li><li>贪心算法并不能保证得到最优解，但是在某些问题上贪心算法的解就是最优解。要会判断一个问题是否能用贪心算法来计算。</li></ul><p><strong>典型例题：</strong></p><ol><li>找零问题</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">n</span>):<br>    m = [<span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>]<br>    money = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(m)<br>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(m):<br>        money[i] = n // j<br>        n = n % j<br>    <span class="hljs-keyword">return</span> money<br><br><br><span class="hljs-built_in">print</span>(change(<span class="hljs-number">999</span>))<br><span class="hljs-comment"># 结果 [9, 1, 2, 0, 1, 4]</span><br></code></pre></td></tr></table></figure><ol start="2"><li>接最大数字</li></ol><p><a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993">https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993</a>?</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe">tpId=<span class="hljs-number">13</span>&amp;tqId=<span class="hljs-number">11185</span>&amp;ru=/exam/oj<br><br><span class="hljs-meta"># s = &#x27;32,94,128,1286,6,71&#x27;</span><br>s = [<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">321</span>]<br><span class="hljs-keyword">new</span><span class="hljs-type">_s</span> = list(map(str, s))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(<span class="hljs-keyword">new</span><span class="hljs-type">_s</span>) - <span class="hljs-number">1</span>):<span class="hljs-type"></span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(<span class="hljs-keyword">new</span><span class="hljs-type">_s</span>) - i - <span class="hljs-number">1</span>):<span class="hljs-type"></span><br>        <span class="hljs-meta"># 一个冒泡排序的思维，前后比较，如果后+前小于&lt;前+后，就换交换两个位置</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j] + <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j + <span class="hljs-number">1</span>] &gt; <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j + <span class="hljs-number">1</span>] + <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j]:<span class="hljs-type"></span><br>            <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j], <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j + <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j + <span class="hljs-number">1</span>], <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j]<br><br>print(<span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-keyword">new</span><span class="hljs-type">_s</span>))<br></code></pre></td></tr></table></figure><ol start="3"><li>活动选择问题</li></ol><p><img src="/../imgs/1685421573606.png" alt="1685421573606"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 贪心结论：最先结束的活动一定是最优解的一部分</span><br><span class="hljs-attribute">def</span> solution(activities):<br><span class="hljs-comment"># 按结束时间排序</span><br>    <span class="hljs-attribute">activities</span>.sort(key=lambda x: x[<span class="hljs-number">1</span>])<br>    <span class="hljs-attribute">res</span> =<span class="hljs-meta"> [activities[0]]</span><br>    <span class="hljs-attribute">for</span> i in range(<span class="hljs-number">1</span>, len(activities)):<br>        <span class="hljs-comment"># 当前活动的开始时间小于等于最后一个入选活动的结束时间</span><br>        <span class="hljs-attribute">if</span> activities[i][<span class="hljs-number">0</span>] &gt;= res[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:<br>            <span class="hljs-attribute">res</span>.append(activities[i])<br><br>    <span class="hljs-attribute">return</span> res<br><br><br><span class="hljs-attribute">activities</span> =<span class="hljs-meta"> [(1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16)]</span><br><span class="hljs-attribute">print</span>(solution(activities))<br></code></pre></td></tr></table></figure><ol start="4"><li><p>区间问题</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">   <br></code></pre></td></tr></table></figure></li></ol><h2 id="4-2-背包问题"><a href="#4-2-背包问题" class="headerlink" title="4.2 背包问题"></a>4.2 背包问题</h2><p>一个小偷在某个商店发现有n个商品，第i个商品价值vi，重wi。他希望拿走的价值最大，但他的背包只能容纳w千克的东西。他应该拿走那些商品?</p><ul><li><p>01背包（动态规划）</p><p>对于一个商品要么完整拿走，要么留下。不能只拿走一部分，或把一个商品多次拿走。</p></li><li><p>分数背包 (贪心算法)</p><p>可以拿走一部分（金砂）</p></li></ul><h2 id="4-3-动态规划"><a href="#4-3-动态规划" class="headerlink" title="4.3 动态规划"></a>4.3 动态规划</h2><p>建议直接看代码随想录：<a href="https://www.programmercarl.com/">https://www.programmercarl.com/</a></p><p>求最优解的问题，有些使用贪心算法无法得到正确答案，可以尝试动态规划。</p><p><strong>对于动态规划问题五步曲：</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>从斐波那契数列了解动态规划</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 递归写斐波那契数列</span><br><span class="hljs-comment"># 递归计算很慢，这里是由于子问题的重复计算</span><br><span class="hljs-attribute">def</span> fib1(n):<br>    <span class="hljs-attribute">if</span> n == <span class="hljs-number">1</span> or n == <span class="hljs-number">2</span>:<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-attribute">else</span>:<br>        <span class="hljs-attribute">return</span> fib1(n - <span class="hljs-number">1</span>) + fib1(n - <span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># 非递归写</span><br><span class="hljs-comment"># 这里就类似动态规划的思想DP ：递推式+重复子问题</span><br><span class="hljs-attribute">def</span> fib2(n):<br>    <span class="hljs-attribute">res</span> =<span class="hljs-meta"> [0, 1, 1]</span><br>    <span class="hljs-attribute">for</span> i in range(n - <span class="hljs-number">2</span>):<br>        <span class="hljs-attribute">if</span> n &gt; <span class="hljs-number">2</span>:<br>            <span class="hljs-attribute">res</span>.append(res[-<span class="hljs-number">1</span>] + res[-<span class="hljs-number">2</span>])<br><br>    <span class="hljs-attribute">return</span> res[n]<br><br><br><span class="hljs-attribute">print</span>(fib1(<span class="hljs-number">100</span>), fib2(<span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure><p><strong>典型例题</strong></p><ol><li><p>钢条切割问题</p></li><li><p>最长公共子序列</p></li></ol><h2 id="4-4-滑动窗口法"><a href="#4-4-滑动窗口法" class="headerlink" title="4.4 滑动窗口法"></a>4.4 滑动窗口法</h2><p>和双指针很类似</p><p>关键词：</p><ul><li>满足xx条件（计算结果，出现次数，同时包含）</li><li>最长&#x2F;最短</li><li>子串&#x2F;子数组&#x2F;子序列</li></ul><p>例如：长度最小的子数组 </p><p>使用思路1：（寻找最长）</p><p><strong>核心：左右双指针（L,R）在起始点，R向右逐位滑动循环</strong></p><p>每次滑动过程中：</p><p>如果：窗内元素满足条件，R向右扩大窗口，并更新最优结果</p><p>如果：窗内元素不满足条件，L向右缩小窗口</p><p>直到R到达结尾</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 最长模板</span><br>s = input()<br>left = <span class="hljs-number">0</span>  <span class="hljs-comment"># 左指针</span><br><span class="hljs-literal">right</span> = <span class="hljs-number">0</span>  <span class="hljs-comment"># 右指针</span><br>max_len = <span class="hljs-number">0</span> <span class="hljs-comment">#</span><br><span class="hljs-comment"># 右指针没有到末尾</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">right</span> &lt; <span class="hljs-built_in">len</span>(s):<br>    <span class="hljs-keyword">while</span> (不满足要求):<br>        <span class="hljs-comment"># 左指针移动</span><br>        left += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 更新最优结果</span><br>    max_len = <span class="hljs-built_in">max</span>(max_len, <span class="hljs-literal">right</span> - left + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 右指针移动</span><br>    <span class="hljs-literal">right</span> += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 更新结果和右指针移动可以换位置，更新结果就不用+1了</span><br></code></pre></td></tr></table></figure><p>使用思路2：（寻找最短）</p><p><strong>核心：左右双指针（L,R）在起始点，R向右逐位滑动循环</strong></p><p>每次滑动过程中：</p><p>如果：窗内元素满足条件，L向右缩小窗口，并更新最优结果</p><p>如果：窗内元素不满足条件，R向右扩大窗口</p><p>直到R到达结尾</p><p><img src="/../imgs/1685001293715.png" alt="1685001293715"></p><h2 id="4-5-双指针"><a href="#4-5-双指针" class="headerlink" title="4.5 双指针"></a>4.5 双指针</h2><p>1.反转字符串</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">s = <span class="hljs-string">&quot;abcdefg&quot;</span><br><br>s = <span class="hljs-built_in">list</span>(s)<br><span class="hljs-attribute">left</span> = <span class="hljs-number">0</span><br><span class="hljs-attribute">right</span> = <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>while <span class="hljs-attribute">left</span> &lt; <span class="hljs-built_in">len</span>(s) // <span class="hljs-number">2</span>:<br>    s<span class="hljs-selector-attr">[left]</span>, s<span class="hljs-selector-attr">[right]</span> = s<span class="hljs-selector-attr">[right]</span>, s<span class="hljs-selector-attr">[left]</span><br>    <span class="hljs-attribute">left</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">right</span> -= <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s)</span></span><br></code></pre></td></tr></table></figure><h2 id="4-6-约瑟夫环问题"><a href="#4-6-约瑟夫环问题" class="headerlink" title="4.6 约瑟夫环问题"></a>4.6 约瑟夫环问题</h2><p>也叫丢手绢问题</p><p>剑指 Offer 62. 圆圈中最后剩下的数字</p><p><a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 思路1：leecode会超时</span><br>n, m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>()), <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>date = []<br>deldate = []<br><span class="hljs-comment"># 所有数据存入date</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    date.append(i)<br>num = <span class="hljs-number">0</span><br><span class="hljs-comment"># 循环 date只有一个数据时停止，此时说明只剩一个数据，符合题意</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(date) &gt; <span class="hljs-number">1</span>:<br>    num += <span class="hljs-number">1</span><br><span class="hljs-comment"># temp = date[0] 先删除，如果是第三个就直接删除了，如果不是第三个就在date末尾添加上，保证一次只删除第三个</span><br>    temp = date.pop(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> num == m:<br>        deldate.append(temp)<br>        num = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        date.append(temp)<br><br><span class="hljs-built_in">print</span>(date[<span class="hljs-number">0</span>])<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 思路2：动态规划--&gt;状态转移方程推理过程没搞明白，先记住</span><br>n, m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>()), <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n, m</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> (solution(n - <span class="hljs-number">1</span>, m) + m) % n<br><br><span class="hljs-built_in">print</span>(solution(n,m))<br></code></pre></td></tr></table></figure><h2 id="4-7-回溯算法"><a href="#4-7-回溯算法" class="headerlink" title="4.7 回溯算法"></a>4.7 回溯算法</h2><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>回溯算法模板框架：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数) &#123;<br>    if (终止条件) &#123;<br>        存放结果;<br>        return;<br>    &#125;<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回溯法三部曲：</p><ul><li>递归函数的返回值以及参数</li><li>回溯函数终止条件</li><li>单层搜索的过程</li></ul><ol><li><p>组合问题</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vim">nums = <span class="hljs-string">&#x27;abc&#x27;</span><br>n = <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">k</span> = <span class="hljs-number">2</span><br><br><br>def permutation(<span class="hljs-keyword">k</span>, nums):<br>    <span class="hljs-keyword">res</span> = []  # 符合条件的结果集<br>    backtracking(<span class="hljs-keyword">k</span>, <span class="hljs-number">0</span>, [], <span class="hljs-keyword">res</span>)<br>    <span class="hljs-keyword">new</span> = [<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-keyword">join</span>(i) <span class="hljs-keyword">for</span> i in <span class="hljs-keyword">res</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><br><br><br># start_index集合从哪里开始遍历,防止出现重复的组合。<br>def backtracking(<span class="hljs-keyword">k</span>, start_index, path, <span class="hljs-keyword">res</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-keyword">k</span>:<br>        <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(path[:])<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(start_index, n):<br>        path.<span class="hljs-keyword">append</span>(nums[i])<br>        backtracking(<span class="hljs-keyword">k</span>, i + <span class="hljs-number">1</span>, path, <span class="hljs-keyword">res</span>)<br>        path.<span class="hljs-keyword">pop</span>()<br><br><br><span class="hljs-keyword">print</span>(permutation(<span class="hljs-keyword">k</span>, nums))<br><br></code></pre></td></tr></table></figure></li><li><p>子集问题</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">s = <span class="hljs-string">&#x27;123&#x27;</span><br>def permutations(s):<br>    <span class="hljs-keyword">res</span> = []<br>    backtracking(s, <span class="hljs-number">0</span>, [], <span class="hljs-keyword">res</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br><br><br>def backtracking(s, start_index, path, <span class="hljs-keyword">res</span>):<br>    <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(path[:])<br>    <span class="hljs-keyword">if</span> start_index&gt;<span class="hljs-built_in">len</span>(s):<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(start_index,<span class="hljs-built_in">len</span>(s)):<br>        path.<span class="hljs-keyword">append</span>(s[i])<br>        backtracking(s, i + <span class="hljs-number">1</span>, path, <span class="hljs-keyword">res</span>)<br>        path.<span class="hljs-keyword">pop</span>()<br><br><span class="hljs-keyword">print</span>(permutations(s))<br><br></code></pre></td></tr></table></figure></li><li><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">   <br></code></pre></td></tr></table></figure></li><li><p>全排列</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vim">from itertools import permutations<br><br>nums = <span class="hljs-string">&#x27;abc&#x27;</span><br># 方法一：直接用permutations<br>ans = <span class="hljs-keyword">list</span>(permutations(nums))<br>ans = [<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-keyword">join</span>(i) <span class="hljs-keyword">for</span> i in ans]<br><span class="hljs-keyword">print</span>(ans)<br><br><br># 方法二：递归+回溯<br>def permutation(nums):<br>    <span class="hljs-keyword">res</span> = []  # 结果集<br>    backtracking(nums, [], <span class="hljs-keyword">res</span>)<br>    <span class="hljs-keyword">res</span> = [<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-keyword">join</span>(i) <span class="hljs-keyword">for</span> i in <span class="hljs-keyword">res</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br><br><br>def backtracking(nums, path, <span class="hljs-keyword">res</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(nums):<br>        <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(path[:])<br>        <span class="hljs-keyword">return</span>  # 结束函数执行<br><br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">if</span> nums[i] in path:<br>            <span class="hljs-keyword">continue</span><br>        path.<span class="hljs-keyword">append</span>(nums[i])<br>        backtracking(nums, path, <span class="hljs-keyword">res</span>)<br>        path.<span class="hljs-keyword">pop</span>()<br><br><br><span class="hljs-keyword">print</span>(permutation(nums))<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-8-区间问题"><a href="#4-8-区间问题" class="headerlink" title="4.8 区间问题"></a>4.8 区间问题</h2>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试准备</title>
    <link href="/2021/10/01/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/10/01/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p><strong>华为面试准备</strong></p><p>技能模板：</p><ul><li>熟悉软件测试理论基础、测试流程、测试用例设计方法和缺陷管理工具，如JIRA、禅道等。</li><li>熟练掌握Python+Selenium+WebDriver自动化测试框架，能够使用PO模式封装页面元素和操作方法，使用Excel和ddt进行数据驱动，使用pytest和allure生成测试报告，能够独立搭建WebUI自动化测试框架。</li><li>熟练使用Postman进行接口测试，能够构造请求参数和校验响应结果，使用Fiddler进行数据抓包和分析，能够定位前后端问题。</li><li>熟练使用JMeter进行性能测试，能够分析性能需求，设计性能场景，构造性能数据，执行性能测试，并分析性能指标和瓶颈。</li><li>熟练使用MySQL数据库，能够编写SQL语句进行数据查询和操作，保证数据的准确性和完整性。</li><li>熟悉APP测试，掌握ADB常用命令，能够使用Monkey对APP进行稳定性测试。</li><li>了解Git分布式版本控制系统。</li><li>了解基于Django框架的Web开发，了解HTML、CSS、Javascript、Bootstrap、Jquery等前端开发技术。</li></ul><ol><li><p>自我介绍</p><p>面试官您好，我叫黄杰，今年24岁，来自重庆合川，2021年毕业于重庆交通大学。</p><p>上一份工作是在一家社交类产品的互联网公司，做测试工程师，主要负责公司已上线产品的版本迭代测试，负责时间比较长的的移动端安卓产品的迭代测试工作。工作内容是以功能测试为主，也会包含部分接口测试、自动化测试、专项测试。</p><p>以上就是我的简单的自我介绍，谢谢面试官。</p></li><li><p>功能测试，工作内容包括哪些？</p><ul><li><strong>根据需求分析和设计测试用例</strong>：覆盖产品的各种功能和场景，确保测试用例的质量和有效性</li><li><strong>执行测试用例</strong>：使用浏览器调试助手、抓包工具等辅助工具，检查产品的功能是否符合预期，是否存在缺陷或问题</li><li><strong>提交和跟踪缺陷</strong>：使用专业的语言和格式，描述缺陷的重现步骤、影响范围和严重程度，与开发人员沟通和协调，验证缺陷的修复情况</li><li><strong>编写测试报告</strong>：总结测试过程中的发现、建议和改进，评估产品的质量和风险，为产品的发布提供参考</li><li><strong>协助完成其他相关工作</strong>：如平台配置、功能发布、视频录制、培训、问题解答、满意度调查等</li></ul></li><li><p>测试用例包含的 要素</p><ul><li><strong>用例编号</strong>：用来唯一标识每条测试用例，方便管理和跟踪。</li><li><strong>功能子模块</strong>：用来表示测试用例所属的功能模块或页面，便于分类和组织。</li><li><strong>测试目的</strong>：用来简要说明测试用例的目标和意义，让人一目了然。</li><li><strong>前置条件</strong>：用来描述测试用例执行之前需要满足的条件，比如数据准备、环境配置等。</li><li><strong>优先级</strong>：用来表示测试用例的重要性和紧急程度，一般分为高、中、低三个等级，指导测试人员安排测试顺序和时间。</li><li><strong>操作步骤</strong>：用来详细描述测试用例的具体操作过程，包括输入、点击、切换等动作，要清晰、完整、准确。</li><li><strong>输入数据</strong>：用来给出测试用例中涉及的参数或变量的具体值，要覆盖正常、异常、边界等情况。</li><li><strong>预期结果</strong>：用来给出测试用例执行后应该出现的结果或反馈，要与需求规格说明书保持一致。</li><li><strong>执行状态</strong>：用来表示测试用例是否已经被执行过，一般分为已执行和未执行两种状态。</li><li><strong>执行结果</strong>：用来表示测试用例执行后的实际结果或反馈，一般分为通过和不通过两种结果。</li><li><strong>对应jira bug-id</strong>：如果测试用例执行结果为不通过，需要在禅道上记录对应的bug，并填写bug的唯一id值，方便追踪和管理。</li><li><strong>编写人</strong>：用来记录测试用例的编写人员，便于沟通和负责。</li><li><strong>执行人</strong>：用来记录测试用例的执行人员，便于沟通和负责。</li><li><strong>备注</strong>：用来补充一些额外的信息，比如业务逻辑、规则、需求、预期结果等，让人看得更明白。</li></ul></li><li><p>黑盒测试和白盒测试的区别</p><ul><li>白盒测试需要从代码句法发现内部代码在算法，溢出，路径，条件等等中的缺点或者错误，进而加以修正。而黑盒测试着重测试软件功能，它并不涉及程序的内部结构和内容特性。黑盒测试并不能取代白盒测试，它与白盒是互补的测试方法，它很可能发现白盒测试不易发现的其他类型错误。</li><li>黑盒测试是从最终用户的角度进行的，而白盒测试是从开发人员的角度进行的</li><li>黑盒测试可以应用于软件测试的每个级别，如单元测试、集成测试、系统测试和验收测试，而白盒测试主要用于单元测试、集成测试和回归测试</li></ul></li><li><p>给你一个场景，设计测试用例</p><ol><li>功能需求、界面：验证软件是否能够打开聊天窗口，输入文本，限制字数在200字以内。</li><li>用户场景、易用性：验证软件是否能够支持不同的输入方式，如键盘、语音、表情等。验证软件是否能够显示输入的文本和字数。验证软件是否能够发送和接收文本消息。</li><li>边界条件：验证软件是否能够正确处理空输入、超过200字的输入、非法字符的输入等。验证软件是否能够提示用户输入错误或超出限制。</li><li>兼容性：验证软件是否能够在不同的平台、环境和设备上正常运行。验证软件是否能够适应不同的屏幕尺寸、分辨率和字体大小。</li><li>安全性：验证软件是否能够保护用户的隐私和数据安全。验证软件是否能够防止恶意攻击和篡改消息。</li></ol></li><li><p>安全测试相关</p><p>用来验证集成在系统内的保护机制是否能够在实际中保护系统不受到非法的侵入。</p><p>常见的有：</p><p><strong>sql注入，DDOS（分布式拒绝服务攻击）, Cookie欺骗、认证和授权、xss攻击、</strong></p><p>DDoS是Distributed Denial of Service的缩写，意思是“分布式拒绝服务”。DDoS攻击是一种恶意的网络攻击，通过利用多个被感染的计算机或设备（称为botnet）向目标服务器、服务或网络发送大量的流量，从而使其无法正常运行。DDoS攻击的目的是阻断正常用户的访问，给目标造成金钱或信誉上的损失。</p><p>SQL注入是一种web安全漏洞，使攻击者可以在应用程序对数据库执行的SQL查询中插入恶意代码。这可能导致攻击者查看、修改或删除数据库中的敏感数据，或者执行其他恶意操作。SQL注入的本质是把用户输入的数据当作代码来执行，违背了“数据与代码分离”的原则。SQL注入的产生需要满足以下两个条件：1、参数用户可控：前端传给后端的参数用户可控。2、参数带入数据库查询：传入的参数拼接到SQL语句中，且带入数据库中查询。</p><p>Cookies欺骗是通过盗取、修改、伪造Cookies的内容来欺骗Web系统,并得到相应权限或者进行相应权限操作的一种攻击方式。</p></li><li><p>常用的linux命令</p><ol><li><p>目录管理 cd pwd ls ll mkdir rmdir mv cp</p></li><li><p>文件管理 </p><ol><li>文件操作命令 touch <strong>vi</strong> cp mv rm ln wc</li><li>文件查看操作 <strong>cat</strong> head more less <strong>tail</strong> find sort **grep ** file</li><li>文件比较操作 diff cmp  which</li></ol></li><li><p>用户管理 useradd(adduser) passwd usermod userdel groupadd </p></li><li><p>权限管理 <strong>chmod</strong> chown chgrp</p></li><li><p>系统设置 alise echo export</p></li><li><p>网络通信 <strong>ifconfig</strong> hostname netstat(显示网络状态) ping </p></li><li><p>磁盘管理 df fu <strong>top</strong> <strong>ps</strong>(ps -ef 或者ps -aux查看所有进程 ，杀掉进程kill -9 pid) vmstat(显示虚拟内存)</p></li><li><p>备份压缩 gzip&#x2F;gunzip <strong>tar</strong> zip&#x2F;unzip</p><p>•cvf-只对文件进行打包，没压缩</p><p>•xvf-对.tar 文件进行解包</p><p>•zcvf-打包同时实现压缩，生成.tar.gz</p><p>•zxvf-对压缩后的打包文件进行解压</p></li><li><p>其他 clear date shutdown poweroff&#x2F;reboot</p></li></ol></li><li><p>黑盒测试和白盒测试的常用方法</p><ol><li><p>黑盒：</p><ol><li>等价类划分法：把所有可能的输入数据划分为若干个互不相交的子集，称为等价类，然后从每个等价类中选取代表性的数据作为测试用例。</li><li>边界值分析法：选取正好等于、刚刚大于或刚刚小于等价类边界的值作为测试数据，因为边界是最容易出错的地方。</li><li>因果图法：根据软件规格说明中的原因和结果，画出因果图，然后转换为决策表，设计测试用例。</li><li>场景法：根据用户使用软件的场景或情境，设计测试用例。</li><li>正交实验设计法：利用正交表选择最优的测试组合，减少测试用例的数量。</li><li>判定表驱动分析法：把作为条件的所有输入的各种组合值以及对应输出值都罗列出来而形成的表格，称为决策表，利用决策表设计测试用例。</li><li>错误推测法：根据经验或直觉推测可能出现错误的地方，设计测试用例。</li></ol></li><li><p>白盒：</p><ol><li>语句覆盖法：要求每条可执行语句至少执行一次。</li><li>判定覆盖法：要求每个判定结构至少有真、假两种结果。</li><li>条件覆盖法：要求每个判定条件至少有真、假两种结果。</li><li>判定&#x2F;条件覆盖法：要求每个判定结构和每个判定条件都至少有真、假两种结果。</li><li>条件组合覆盖法：要求每个判定结构中所有可能的条件组合都至少出现一次。</li><li>路径覆盖法：要求程序中所有可能的路径都至少执行一次</li></ol></li></ol></li><li><p>接口测试相关</p><ol><li><p>接口类型</p><ul><li>对外接口：全面性测试</li><li>对内接口：漏洞测试、破坏性测试</li></ul></li><li><p>postman</p></li><li><p>数据埋点测试</p><p>埋点是在程序中的某个位置加上一个标记，当用户触发到某个行为的时候，就采集一下数据，然后将数据上报到某个位置进行存储，埋点的最终目的是收集到相关的数据，提供数据支撑。</p><p>上家公司是使用的第三方统计平台，GIO。</p></li></ol></li><li><p>专项测试相关</p><ol><li><strong>兼容性测试</strong>：测试App在不同的操作系统版本、屏幕分辨率、厂商ROM和网络类型下的功能和性能表现。</li><li><strong>流量测试</strong>：测试App在用户操作和后台运行时的流量消耗情况，优化流量使用效率。</li><li><strong>电量测试</strong>：测试App在不同的使用场景下的电量消耗情况，优化电池使用寿命。</li><li><strong>弱网络测试</strong>：测试App在网络不稳定、信号弱、中断等情况下的功能和性能表现，优化网络请求和缓存机制。</li><li><strong>稳定性测试</strong>：测试App在长时间运行或高压力下的稳定性，避免出现闪退、卡死、内存泄漏等问题。</li><li><strong>安全测试</strong>：测试App的安装包、敏感信息、账户密码、数据通信等方面的安全性，防止被反编译、劫持、注入、攻击等。</li><li><strong>环境相关测试</strong>：测试App在不同的用户环境下的功能和性能表现，考虑干扰因素、权限设置、第三方依赖、冲突场景等。</li></ol></li><li><p>性能测试（稳定性测试、压力、负载）</p><ol><li><p>用来测试软件在集成系统中 的运行性能的</p></li><li><p>性能测试的目标是度量系统相对于预定义目标的差距</p></li><li><p>性能测试工具，如Loadrunner, Jmeter, SilkPerformer, WebLoad</p></li><li><p>性能测试主要指标</p><ol><li><p>外部 </p><p>• 吞吐量：每秒钟系统能够处理的请求数、任务数 </p><p>• 响应时间：服务处理一个请求或一个任务的耗时 </p><p>• 错误率：一批请求中结果出错的请求所占比例</p></li><li><p>内部 </p><p>• 服务器的CPU、内存、网络、磁盘IO等</p></li></ol></li></ol></li><li><p>测试模型</p><p>​</p></li><li><p>怎么做好测试？</p></li><li><p>操作系统相关</p></li><li><p>from collections import Counter</p></li><li><p>测试的目的：发现被测试的产品和用户需求的差异，也就是缺陷</p><p>• 尽早介入测试发现缺陷，减少返工、降低开发维护成本</p><p>• 持续改进过程，帮助定义需求和设计</p><p>• 提高客户满意度，扩大市场份额</p><p>• 对产品质量完成全面评估、为产品发布、部署、鉴定和决策者提供信息</p><p>• 预防缺陷，通过缺陷分析和原因总结，规避后续同类缺陷的产生再犯</p></li><li><p>数据库mysql相关</p><ol><li><p>数据库模式定义语言DDL(Data Definition Language) </p><ol><li>CREATE</li><li>ALTER</li><li>DROP</li><li>TRUNCATE</li></ol></li><li><p>数据操作语言DML（Data Manipulation Language），用户通过它可以实现对数据库的基本操作</p><p>在DML中，应用程序可以对数据库作插，删，改，排，检等五种操作。</p><ol><li>INSERT</li><li>UPDATE</li><li>DELETE</li><li>SELECT</li></ol></li><li><p>查询语句标准格式</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> 字段 <br><span class="hljs-keyword">from</span> 表<br><span class="hljs-keyword">where</span> 条件<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 字段<span class="hljs-number">1</span>，字段<span class="hljs-number">2.</span>.；<br></code></pre></td></tr></table></figure></li><li><p>多表连接</p><ol><li>等值连接</li><li>不等连接</li><li>外连接（左连接、右连接）</li><li>自连接</li></ol></li><li><p>分组查询</p></li><li><p><img src="/../imgs/1715185646815.png" alt="1715185646815"></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> 字段 <br><span class="hljs-keyword">from</span> 表<br><span class="hljs-keyword">where</span> 条件<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组条件<br><span class="hljs-keyword">having</span> 符合条件的组<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 字段<span class="hljs-number">1</span>，字段<span class="hljs-number">2.</span>.；<br></code></pre></td></tr></table></figure></li><li><p>子查询</p></li></ol></li><li><p>IM push推送机制</p><p><a href="http://www.taodudu.cc/news/show-546423.html?action=onClick">http://www.taodudu.cc/news/show-546423.html?action=onClick</a></p><p>实现原理：</p><ol><li>应用服务器与推送服务器建立长连接。</li><li>应用服务器把推送请求和对应的消息内容 发送给推送服务器。</li><li>推送服务根据应用服务器传递的参数推送到指定的设备上。</li></ol><p>Android：海外谷歌FCM、国内是各厂商通道push和第三方通道PUSH</p><p>IOS：APNS</p><p>发现的印象深刻的问题：</p><ol><li><p>push重复发送</p><p>原因：推送了一条非透传消息，本来应该手机系统服务去解析这个通知然后展示到通知栏，但是app也去解析了一次，所以展示了两条一样的消息。解决办法：app不去解析。</p><p>透传是指数据传输时，不对数据做任何特殊的处理，原封不动地发送给接收方。也就是说，透传的通道完全“透明”的，它不管发送方传输的是什么数据，只负责将数据送到接收方手上即可，接收方可以直接解析出发送方发送的数据信息。</p><p>非透传则是指数据传输时，需要在数据传输前对数据进行加密或者压缩等操作，然后再进行传输。当接收方收到数据时，需要对加密或者压缩后的数据进行解密或者解压缩操作，才能获得真正的数据信息。所以，非透传通常需要使用特定的协议和算法来实现。</p><p><a href="https://www.iotrouter.com/news/1263.html">https://www.iotrouter.com/news/1263.html</a></p></li><li><p>通知过多会崩溃</p><p>原因：数组越界。客户端写的接收push的数组比较小，扩大了内存。</p></li><li><p>push交互区域是整个区域</p><p>原因：安卓开发错误使用了dialog函数。解决办法：修改了函数。</p></li></ol></li><li><p>Cookie、Session、Token区别在哪？</p><ol><li>session是诞生并保存在服务器，由服务器主导一切。</li><li>cookie是一种数据载体，把session放在cookie中送到客户端，cookie跟随每个http请求发送出去。</li><li>Token是诞生在服务器，但保存在浏览器，由客户端主导一切。可以放在cookie或Storage里面。持有Token就像持有令牌一样可以访问服务器。</li></ol><p>由于http是无状态的，想要实现保持登录，需要依靠cookie，cookie是一种可以实现每次http请求都自带数据给服务器的的技术。说白了Cookie就是一种存储在浏览器的数据而已。</p><p><img src="/../imgs/1715185663670.png" alt="1715185663670"></p><p>Session：当你登录成功后，在服务器生成SessionID和会话结束时间（以及一些其他参数），服务器Set-Cookie并且把SessionID加入Cookie，会话结束时间设置为cookie的有效期，浏览器拿到并保存Cookie，再依靠Cookie特性（每次http请求都会带上cookie）实现保持登录，直到Cookie的有效期失效，浏览器自行删除这个Cookie。</p><p>SessionID：是没有规律的字符串，服务器再发送Cookie之前会对这个含有SessionID的Cookie进行签名，所有是有一定安全性的。 </p><p><img src="/../imgs/1715185677335.png" alt="1715185677335"></p><p>由于用户体量的增加，服务器存储SessionID会引发很多不合理的地方，就诞生了新的技术JWT(JSON Web Token)。token是通过加密算法生成一个加密字符串，包含了用户的身份和权限信息，客户端每次请求都带上这个token，服务器端根据密钥解密token进行验证。</p><p>JWT是由三部分组成的：header.payload.·</p><ul><li><p>header 声明需要用什么算法来生成签名</p></li><li><p>payload 一些特定数据，比如有效期之类</p></li><li><p>signature签名</p><p><img src="/../imgs/1715185697160.png" alt="1715185697160"></p></li></ul><p><img src="/../imgs/1715185708040.png" alt="1715185708040"></p><p>​</p></li><li><p>网络协议模型</p><ol><li><p><strong>物理层协议</strong>：负责定义物理设备如何传输数据，例如双绞线、光纤、无线电波等。</p></li><li><p><strong>数据链路层协议</strong>：负责在物理层之上建立逻辑连接，确定数据的分组方式和意义，例如以太网、ARP、MAC等。</p></li><li><p><strong>网络层协议</strong>：负责在网络中进行寻址和路由，实现不同网络之间的互联，例如IP、ICMP、IGMP等。</p></li><li><p><strong>传输层协议</strong>：负责在网络层之上提供可靠或不可靠的数据传输服务，例如TCP、UDP等。</p></li><li><p><strong>应用层协议</strong>：负责定义应用程序之间的通信规则，例如HTTP、FTP、SMTP、DNS等</p></li></ol></li><li><p>python相关知识：</p><ol><li><p>sort和sorted底层实现原理</p><p>timsort算法，可以简单理解为 归并排序 和 二分插入排序 算法的混合体，号称世界上最好的排序算法。</p></li><li><pre><code class="hljs">__init__ 和 __new__</code></pre><p>相同点：</p><ol><li>都是类中的内置方法</li><li>都会在创建对象时自动调用</li></ol><p>不同点：</p><ol><li>new是创建实例，init是初始化实例</li><li>new方法在init方法之前被调用</li><li>new是类方法，init是实例方法</li></ol></li><li><p>Python除了全局作用域和局部作用域，还有哪些作用域？</p><p>嵌套作用域是指在一个函数内部定义另一个函数，内部函数可以访问外部函数的变量；</p><p>内置作用域是指Python预定义的一些变量和函数，例如print、len、range等</p></li><li><p>深拷贝、浅拷贝？</p><ul><li><p>浅拷贝</p><p>python拷贝一般都是浅拷贝，拷贝时，对象包含的子对象不拷贝，因此，源对象与拷贝对象会引用同一个子对象。</p></li><li><p>深拷贝</p><p>使用copy模块deepcopy函数，递归拷贝对象中包含子对象，源对象和拷贝对象所有的子对象也不相同。</p></li></ul></li></ol></li><li><p>婚恋社交产品核心功能：</p><ul><li><p><strong>实名认证</strong>：要求每一位注册的用户提供真实有效的资料，通过平台的认可方可进入。这样可以保证用户的安全和信任，也可以提高用户的质量和活跃度</p></li><li><p><strong>在线聊天</strong>：用户可以和朋友用语音和文字进行沟通交流是社交APP的首要功能，除此之外，还可实现视频通话，更加近距离的接触</p></li><li><p><strong>群聊互动</strong>：可支持2人以上的群组聊天，邀请共同兴趣爱好的人进入同一个群，方便彼此之间的交流</p><ul><li>聊天功能、消息管理、消息推送、权限管理、隐私管理、成员管理、网络环境、兼容测试</li></ul></li><li><p><strong>陌生交友</strong>：通过社交APP，用户可以扩大自己的交往的圈子，还可以很快结交到有着相同兴趣爱好的朋友</p></li><li><p><strong>社交圈</strong>：用户可以发表自己的心情、照片，随时随地与家人、朋友分享自己的经历</p></li><li><p><strong>定位服务</strong></p><ul><li><strong>使用系统自带的定位服务和GPS</strong>：这种方法是利用手机系统自带的定位服务和GPS功能，来获取用户的经纬度和地址信息。这种方法需要用户授予app使用位置的权限，并且可能受到磁场或其他环境的干扰</li><li><strong>使用外接SDK</strong>：这种方法是利用第三方提供的软件开发包（SDK），如高德SDK、百度SDK等，来获取用户的经纬度和地址信息。这种方法也需要用户授予app使用位置的权限，并且可能需要申请开发者账号和密钥</li><li><strong>使用外部接口</strong>：这种方法是利用外部提供的接口，如百度API、聚合数据API等，来获取用户的外网IP地址，然后根据IP地址推测用户的大致位置。这种方法不需要用户授予app使用位置的权限，但是可能不够准确，并且可能需要申请开发者账号和密钥</li></ul></li></ul></li><li><p>手撕算法题</p><p>题目难度和范围接近OD笔试，以LeetCode中的简单题和中等题为主，而且考察种子题的概率更大。所谓种子题，是指各种算法中最基础的那些题目，比如</p><ol><li>二分查找：LC35搜索插入位置</li><li>滑动窗口：LC3无重复字符的最长子串</li><li>DFS和BFS：LC200岛屿面积</li><li>回溯：LC46全排列</li><li>动态规划：LC300最长递增子序列等等</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
