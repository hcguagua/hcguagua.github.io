<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Locust 性能测试</title>
    <link href="/2024/05/21/Locust-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/05/21/Locust-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="主流性能测试工具对比"><a href="#主流性能测试工具对比" class="headerlink" title="主流性能测试工具对比"></a><strong>主流性能测试工具对比</strong></h3><ol><li>JMeter<ol><li>优点:开源免费、易用性强、支持多种协议测试、可视化报告</li><li>缺点:性能测试能力较弱,对大并发和长时间测试支持不足</li></ol></li><li>Locust<ol><li>优点:开源免费、基于Python编写、易于编写复杂场景、分布式压测支持</li><li>缺点:仅支持HTTP&#x2F;WebSocket协议、编写压测脚本需要一定Python基础</li></ol></li><li>Gatling<ol><li>优点:性能优秀、支持多种协议、支持分布式压测、报告详细</li><li>缺点:学习曲线较steep、需要一定Scala编程能力</li></ol></li><li>Loadrunner<ol><li>优点:功能全面、支持多种协议、报告丰富、专业性强</li><li>缺点:需要付费授权、使用复杂度高、对测试人员技能要求高</li></ol></li><li>Siege<ol><li>优点:开源免费、易于上手、针对HTTP&#x2F;HTTPS协议优化良好</li><li>缺点:功能较为简单、不支持分布式压测、报告信息较少</li></ol></li><li>Artillery<ol><li>优点:开源免费、易于上手、支持多种协议、可定制化程度高</li><li>缺点:性能相对较弱、报告信息较少、社区活跃度不高</li></ol></li></ol><h3 id="Locust相关文档"><a href="#Locust相关文档" class="headerlink" title="Locust相关文档"></a><strong>Locust相关文档</strong></h3><p>github地址：<a href="https://github.com/locustio/locust">https://github.com/locustio/locust</a></p><p>官方文档地址：<a href="https://docs.locust.io/">docs.locust.io</a></p><h3 id="常见的上线策略"><a href="#常见的上线策略" class="headerlink" title="常见的上线策略"></a><strong>常见的上线策略</strong></h3><ol><li>金丝雀发布(Canary Release):<ol><li>将新版本先部署给少量代表性用户(金丝雀用户组),监控使用情况。</li><li>确认无重大问题后,逐步扩大新版本的发布范围。</li></ol></li><li>蓝绿部署(Blue-Green Deployment):<ol><li>在生产环境中维护两套完全相同的环境(蓝色和绿色)。</li><li>新版本先部署到其中一个环境,测试无误后切换流量。</li></ol></li><li>灰度发布(Gradual Rollout):<ol><li>将新版本逐步推广到用户群中,如先发布给少部分用户。</li><li>监控反馈情况,确认无重大问题后再扩大发布范围。</li></ol></li><li>A&#x2F;B测试(A&#x2F;B Testing):<ol><li>将用户分成A&#x2F;B两组,A组使用旧版本,B组使用新版本。</li><li>对比两组用户行为数据,评估新功能的影响。</li></ol></li><li>功能开关(Feature Flags):<ol><li>将新功能与主干代码解耦,可以控制新功能在生产环境的开启时机。</li><li>方便快速回滚和测试新功能。</li></ol></li><li>分阶段推广(Incremental Rollout):<ol><li>将新版本分阶段推广到用户群中,先让少部分用户试用。</li><li>观察反馈情况,确认无重大问题后再逐步扩大范围。</li></ol></li></ol><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h3><ol><li>安装：直接 pip 安装就行<ol><li><pre><code class="Shell">pip3 install locust# 查看版本locust -V# 输出类似下面的内容就代表安装成功了！！！locust 2.27.0 from /usr/local/lib/python3.10/site-packages/locust (python 3.10.6)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2.</span> 案例模版（需要新建 名为 locustfile.py  的文件）<br>   <span class="hljs-number">1.</span> ```python<br>      <span class="hljs-keyword">from</span> locust <span class="hljs-keyword">import</span> HttpUser, task, between<br>      <br>      <br>      <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldUser</span>(<span class="hljs-title class_ inherited__">HttpUser</span>):<br>          host = <span class="hljs-string">&#x27;http://120.46.177.228&#x27;</span><br>          wait_time = between(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>      <br><span class="hljs-meta">          @task</span><br>          <span class="hljs-keyword">def</span> <span class="hljs-title function_">webhook</span>(<span class="hljs-params">self</span>):<br>              self.client.post(<span class="hljs-string">&#x27;/webhook1&#x27;</span>)<br></code></pre></td></tr></table></figure></code></pre></li></ol></li><li>终端运行<ol><li><pre><code class="Shell">locust# 启动多个节点什么是分布式负载生成?Locust支持跨多个进程和机器运行负载测试,以产生更高水平的负载。这是通过运行一个Locust实例在主节点模式,以及一个或多个实例在工作节点模式来实现的。主节点运行Web UI并协调工作节点,而工作节点运行实际的用户模拟。在单台机器上运行要在单台机器上以分布式方式运行Locust,可以使用--processes标志启动主节点和多个工作节点进程。例如: locust --processes 4 将启动1个主节点和4个工作节点进程。您也可以使用 --processes -1 自动检测逻辑核心数并为每个核心启动一个工作节点。在多台机器上运行在一台机器上以locust --master启动主节点实例。然后在每台工作节点机器上运行locust --worker --master-host &lt;主节点主机&gt;。您也可以使用locust-swarm工具来自动化分布式设置并处理防火墙/网络访问问题。分布式选项--master-host: 设置主节点的主机名/IP(默认为localhost)。--master-port: 设置主节点的端口号(默认为5557)。--master-bind-host: 确定主节点将绑定的网络接口(默认为全部)。--master-bind-port: 确定主节点将监听的网络端口(默认为5557)。--expect-workers: 与--headless模式一起使用,等待指定数量的工作节点连接后再开始测试。跨节点通信您可以使用内置的事件钩子实现主节点和工作节点之间的自定义消息传递。这允许在分布式设置中协调测试设置和其他功能。提高Locust性能如果您正在运行大规模测试,请考虑使用更快的FastHttpUser而不是默认的HttpUser。这可以大大提高Locust的性能。</code></pre></li></ol></li><li>访问 <a href="http://localhost:8089/">http://localhost:8089/</a> <ol><li>Number of users (peak concurrency)  –&gt; 用户数量（高峰并发） </li><li>Ramp up (users started&#x2F;second)  –&gt; 递增用户数量</li><li>Host –&gt; 主机域名</li><li>Advanced options –&gt; 可选项<ol><li>Run time –&gt; 运行时间</li></ol></li></ol></li><li>相关页面 性能测试指标<ol><li>Statistics【表格数据】</li><li>Charts【图表数据】<ol><li>Total Requests per Secend<ol><li>RPS</li><li>Failures&#x2F;s</li></ol></li><li>Response Times(ms)<ol><li>95th Percentile</li><li>Average Response Time</li></ol></li><li>Number of Users</li></ol></li></ol></li></ol><h3 id="指标说明"><a href="#指标说明" class="headerlink" title="指标说明"></a><strong>指标说明</strong></h3><p><img src="/../imgs/image.png" alt="img"><img src="/../imgs/image-1716222963213.png" alt="img"></p><h4 id="Statistics页面部分"><a href="#Statistics页面部分" class="headerlink" title="Statistics页面部分"></a><strong>Statistics页面部分</strong></h4><ol><li>Type：请求方式</li><li>Name：接口路由</li><li>Requests：请求数量</li><li>Fails：请求失败的数量</li><li>Median：响应时间中位数</li><li>95%ile(ms)：95% 响应时间。表示 95% 的请求在这个时间内完成。</li><li>99%ile(ms)：99% 响应时间。表示 99% 的请求在这个时间内完成。</li><li>Average(ms)：平均响应时间</li><li>Min(ms)：最小响应时间</li><li>Max(ms)：最大响应时间</li><li>Average size (bytes)：每个请求的平均响应数据大小,单位为字节。</li><li>Current RPS：当前的每秒请求数。</li><li>Current Failures&#x2F;s：每秒钟发生的失败请求数量。</li></ol><h4 id="Charts页面部分"><a href="#Charts页面部分" class="headerlink" title="Charts页面部分"></a><strong>Charts页面部分</strong></h4><ol><li>RPS (Requests per Second)：每秒请求数。表示每秒发送的请求数量。这个指标用来衡量系统的吞吐量。</li><li>Failures&#x2F;s：每秒失败数。表示每秒发生的失败请求数量。这帮助用户了解失败请求的频率。</li><li>95th Percentile：95 百分位数。表示响应时间分布中,有95%的响应时间小于等于这个值。它反映了系统在高负载下的响应性能。</li><li>Average Response Time：平均响应时间。所有请求的平均响应时间。这个指标反映了系统的总体响应性能。</li><li>Number of Users：用户数。当前运行的虚拟用户数，代表正在模拟的并发用户数量。</li></ol><h3 id="发现性能瓶颈简略步骤"><a href="#发现性能瓶颈简略步骤" class="headerlink" title="发现性能瓶颈简略步骤"></a><strong>发现性能瓶颈简略步骤</strong></h3><p>以下现象表示 服务器系统处理请求的效率下降。</p><ul><li>RPS 不再增加，甚至有所下降，表明系统已经无法处理更多的请求。</li><li>失败请求数增加，表明部分请求由于系统资源不足而无法成功处理。</li><li>系统资源（特别是 CPU）使用率达到 100%，表明系统资源已被完全占用。</li></ul><h4 id="1-逐步增加并发用户数"><a href="#1-逐步增加并发用户数" class="headerlink" title="1. 逐步增加并发用户数"></a><strong>1. 逐步增加并发用户数</strong></h4><p>每次增加 20 个并发用户，例如从 50 增加到 70，再到 90 等等。每次增加后，观察并记录以下指标：</p><ul><li>平均响应时间</li><li>95th 百分位响应时间</li><li>RPS</li><li>失败请求数</li><li>系统资源使用率（可以通过系统监控工具如 <code>htop</code>、<code>top</code> 或 <code>vmstat</code> 进行监控）</li></ul><h4 id="2-找到系统极限"><a href="#2-找到系统极限" class="headerlink" title="2. 找到系统极限"></a><strong>2. 找到系统极限</strong></h4><p>继续增加并发用户数，直到发现以下情况之一：</p><ul><li>响应时间显著增加（例如从 800ms 增加到 2500ms）。</li><li>RPS 不再增加或下降（例如从 45 RPS 降到 40 RPS）。</li><li>失败请求数显著增加（例如从 0 增加到 15）。</li><li>系统资源（特别是 CPU 或内存）使用率达到 100%。</li></ul><h4 id="3-示例结果"><a href="#3-示例结果" class="headerlink" title="3. 示例结果"></a><strong>3. 示例结果</strong></h4><p>假设以下是你逐步增加并发用户数后的观察结果：</p><table><thead><tr><th align="center">并发用户数</th><th align="center">平均响应时间</th><th align="center">95th 响应时间</th><th align="center">RPS</th><th align="center">失败请求数</th><th align="center">CPU 使用率</th></tr></thead><tbody><tr><td align="center">50</td><td align="center">800 ms</td><td align="center">1300 ms</td><td align="center">35</td><td align="center">0</td><td align="center">50%</td></tr><tr><td align="center">70</td><td align="center">850 ms</td><td align="center">1350 ms</td><td align="center">40</td><td align="center">0</td><td align="center">60%</td></tr><tr><td align="center">90</td><td align="center">900 ms</td><td align="center">1400 ms</td><td align="center">43</td><td align="center">2</td><td align="center">75%</td></tr><tr><td align="center">110</td><td align="center">1500 ms</td><td align="center">2000 ms</td><td align="center">45</td><td align="center">5</td><td align="center">90%</td></tr><tr><td align="center">130</td><td align="center">2500 ms</td><td align="center">3000 ms</td><td align="center">40</td><td align="center">15</td><td align="center">100%</td></tr></tbody></table><p>在并发用户数达到 130 时，系统各项指标表明已达到瓶颈：</p><ul><li>平均响应时间显著增加到 2500 ms。</li><li>RPS 不再增加，甚至有所下降到 40。</li><li>失败请求数显著增加到 15。</li><li>CPU 使用率达到 100%。</li></ul><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h4><p>在这个示例中，系统的并发瓶颈大约在 130 并发用户左右。当并发用户数超过 130 时，系统的响应时间显著增加，RPS 不再增加，并且失败请求数显著增加，同时 CPU 使用率达到了 100%。</p><p>通过这些步骤和分析，你可以确定系统的性能瓶颈和最大支持的并发用户数，并进行相应的优化和调整。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基础算法</title>
    <link href="/2024/05/09/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    <url>/2024/05/09/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-：导论"><a href="#第一章-：导论" class="headerlink" title="第一章 ：导论"></a>第一章 ：导论</h1><p><strong>算法概念</strong></p><p>算法（Algorithm）：一个计算过程，解决问题的方法。</p><blockquote><p>程序&#x3D;数据结构+算法</p></blockquote><p><strong>时间复杂度</strong></p><ul><li><p>用来评估算法运行时间的一个式子（单位）。</p></li><li><p>一般来说，时间复杂度高的算法比复杂度低的算法慢</p></li><li><p>常见的时间复杂度</p><p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n²logn)&lt;O(n³)</p></li><li><p>复杂问题的时间复杂度</p><p>O(n!)  O(2ⁿ)  O(nⁿ)</p><p>​</p></li></ul><p></p><p>O(n)</p><ul><li>O 可以理解为大约</li><li>n  可以理解为一个单位</li></ul><p><strong>如何简单快速的判断算法复杂度</strong></p><p>大多数简单情况：</p><ul><li>确定问题规模n</li><li>循环减半过程-&gt;logn</li><li>k层关于n的循环-&gt;n的k次方</li></ul><p>复杂情况：根据算法执行过程判断</p><p><strong>空间复杂度</strong></p><ul><li>用来评估算法内存占用大小的式子</li><li>空间复杂度的表示方式和时间复杂度完全一样<ul><li>算法使用了几个变量：O(1)</li><li>算法使用了长度为n的一卫列表：O(n)</li><li>算法使用了m行n列的二维列表：O(mn)</li></ul></li><li>‘空间换时间’ ：时间比空间重要</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h2><p><strong>递归的两个特点</strong></p><ul><li>调用自身</li><li>结束条件</li></ul><p><strong>递归实例</strong>：汉诺塔问题</p><p><img src="/../imgs/1673877309685.png" alt="1673877309685"></p><p><img src="/../imgs/1673877452210.png" alt="1673877452210"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">def hanoi(n, <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, c): # a经过b移动到c<br>    if n &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">hanoi</span>(n - <span class="hljs-number">1</span>, a, c, b)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;moving from %s to %s&#x27;</span> % (a, c))<br>        <span class="hljs-built_in">hanoi</span>(n - <span class="hljs-number">1</span>, b, a, c)<br><br><br><span class="hljs-built_in">hanoi</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="第二章：查找和排序"><a href="#第二章：查找和排序" class="headerlink" title="第二章：查找和排序"></a>第二章：查找和排序</h1><h2 id="2-1查找"><a href="#2-1查找" class="headerlink" title="2.1查找"></a>2.1查找</h2><ul><li>查找：在一些数据元素中，通过以一定的方法找出与给定关键字相同的数据元素的过程</li><li>列表查找（线性表查找）：从列表中查找指定元素<ul><li>输入：列表、待查找元素</li><li>元素下标（未找到元素时一般返回None或-1）</li></ul></li><li>内置列表查找函数：index（）    是顺序查找，二分查找必须是有序的（不能保证是排序的）</li></ul><p><strong>顺序查找</strong></p><p>也叫线性查找，从列表第一个元素开始，顺序进行搜索，直到找到元素或搜索到列表最后一个元素为止。</p><p>时间复杂度：O(n)</p><p><strong>二分查找</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def binary_search(li, val):<br>    left = <span class="hljs-number">0</span><br>    <span class="hljs-literal">right</span> = <span class="hljs-built_in">len</span>(li) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left &lt;= <span class="hljs-literal">right</span>:  <span class="hljs-comment"># 候选区有值</span><br>        <span class="hljs-keyword">mid</span> = (left + <span class="hljs-literal">right</span>)<span class="hljs-comment"> // 2  # 循环减半</span><br>        <span class="hljs-keyword">if</span> li[<span class="hljs-keyword">mid</span>] == val:<br>            <span class="hljs-literal">return</span> <span class="hljs-keyword">mid</span><br>        elif li[<span class="hljs-keyword">mid</span>] &gt; val:  <span class="hljs-comment"># 待查找的值在mid左侧</span><br>            <span class="hljs-literal">right</span> = <span class="hljs-keyword">mid</span> - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 待查找的值在mid右侧</span><br>            left = <span class="hljs-keyword">mid</span> + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-literal">return</span> None<br><br><br>li = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br>print(binary_search(li, <span class="hljs-number">3</span>))<br><span class="hljs-comment"># 结果为2</span><br></code></pre></td></tr></table></figure><p>时间复杂度：O(logn)</p><h2 id="2-2排序"><a href="#2-2排序" class="headerlink" title="2.2排序"></a>2.2排序</h2><ul><li>排序：将一组’无序’的记录序列调整为’有序’的记录序列</li><li>列表排序：将无序列表变为有序列表<ul><li>输入：列表</li><li>输出：有序列表</li></ul></li><li>升序与降序</li><li>内置排序函数sort()</li></ul><p>排序 LOW B三人组</p><ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li></ul><p>都是原地排序。</p><h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a><strong>1. 冒泡排序</strong>（Bubble Sort）</h3><ul><li>列表每两个相邻的数，如果前面比后面大，则交换这两个数。</li><li>一趟排序完成后，则无序区减少一个数，有序区增加一个数。</li><li>代码关键点：趟、无序区范围</li><li>时间复杂度：O(n²)</li></ul><p>初始代码：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">def bubble_sort(<span class="hljs-built_in">li</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-built_in">li</span>) - <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-built_in">li</span>) - i - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">li</span>[j] &gt; <span class="hljs-built_in">li</span>[j + <span class="hljs-number">1</span>]:<br>                <span class="hljs-built_in">li</span>[j], <span class="hljs-built_in">li</span>[j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">li</span>[j + <span class="hljs-number">1</span>], <span class="hljs-built_in">li</span>[j]<br></code></pre></td></tr></table></figure><p>优化后的代码：冒泡排序的一趟排序没有发生交换，则说明列表已经有序，可以直接结束算法。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs maxima">def bubble_sort(<span class="hljs-built_in">li</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-built_in">li</span>) - <span class="hljs-number">1</span>):<br>        exchange = False<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-built_in">li</span>) - i - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">li</span>[j] &gt; <span class="hljs-built_in">li</span>[j + <span class="hljs-number">1</span>]:  #  逆序就 &lt; <br>                <span class="hljs-built_in">li</span>[j], <span class="hljs-built_in">li</span>[j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">li</span>[j + <span class="hljs-number">1</span>], <span class="hljs-built_in">li</span>[j]<br>                exchange = True<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exchange:<br>            <span class="hljs-built_in">return</span><br><br><br><span class="hljs-built_in">li</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">18</span>]<br>bubble_sort(<span class="hljs-built_in">li</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">li</span>)<br></code></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a><strong>2. 选择排序</strong></h3><ul><li>一趟排序记录最小的数，放到第一个位置</li><li>再一趟排序记录列表无序区最小的数，放到第二个位置</li><li>算法关键点：有序区和无序区、无序区最小数的位置</li><li>时间复杂度：O(n²)</li></ul><p>初步想法代码：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">select_sort_simple</span>(li):<br>    li_new = []<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(li)):  # 复杂度<span class="hljs-built_in">O</span>(n)<br>        min_val = <span class="hljs-built_in">min</span>(li)  # 复杂度<span class="hljs-built_in">O</span>(n)<br>        li_new.<span class="hljs-built_in">append</span>(min_val)<br>        li.<span class="hljs-built_in">remove</span>(min_val)  # 复杂度<span class="hljs-built_in">O</span>(n)<br>    return li_new<br>#  整体代码复杂度<span class="hljs-built_in">O</span>(n²)<br></code></pre></td></tr></table></figure><p>不是原地排序，需要开辟新的列表。需要尽量考虑原地排序，减少复杂度。</p><p>优化代码：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs maxima">def select_sort(<span class="hljs-built_in">li</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-built_in">li</span>) - <span class="hljs-number">1</span>):  # i是第几趟<br>        min_loc = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, len(<span class="hljs-built_in">li</span>)):  # 然后把最小的放前面<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">li</span>[j] &lt; <span class="hljs-built_in">li</span>[min_loc]:<br>                min_loc = j<br>        <span class="hljs-keyword">if</span> min_loc != i:<br>            <span class="hljs-built_in">li</span>[i], <span class="hljs-built_in">li</span>[min_loc] = <span class="hljs-built_in">li</span>[min_loc], <span class="hljs-built_in">li</span>[i]<br>    <span class="hljs-built_in">return</span> <span class="hljs-built_in">li</span><br><br><br><span class="hljs-built_in">li</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">18</span>]<br><span class="hljs-built_in">print</span>(select_sort(<span class="hljs-built_in">li</span>))<br></code></pre></td></tr></table></figure><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a><strong>3. 插入排序</strong></h3><ul><li>初始时手里（有序区）一张牌</li><li>每次从无序区摸一张牌，插入到手里已有牌的正确位置</li><li>时间复杂度：O(n²)</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">def <span class="hljs-keyword">insert_sort(li):</span><br><span class="hljs-keyword"></span>    for i in range(len(li) - <span class="hljs-number">1</span>):<br>        tmp = li[i]<br>        <span class="hljs-keyword">j </span>= i - <span class="hljs-number">1</span>  <span class="hljs-comment"># j指手里的牌的下标</span><br>        while li[<span class="hljs-keyword">j] </span>&gt; tmp <span class="hljs-keyword">and </span><span class="hljs-keyword">j </span>&gt;= <span class="hljs-number">0</span>:<br>            li[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>] = li[<span class="hljs-keyword">j]</span><br><span class="hljs-keyword"></span>            <span class="hljs-keyword">j </span>-= <span class="hljs-number">1</span><br>        li[<span class="hljs-keyword">j </span>+ <span class="hljs-number">1</span>] = tmp<br><br><br>li = [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>]<br><span class="hljs-keyword">insert_sort(li)</span><br><span class="hljs-keyword"></span>print(li)<br></code></pre></td></tr></table></figure><p>排序NB三人组</p><ul><li>快速排序</li><li>堆排序</li><li>归并排序</li></ul><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a><strong>4. 快速排序</strong></h3><p>快速排序思路：</p><ul><li><p>取一个元素（第一个元素），是元素P归位</p></li><li><p>列表被P分成两部分，左边都比P小，右边都比P大</p></li><li><p>递归完成排序</p></li></ul><p>快速排序的效率问题：</p><ul><li>快速排序的时间复杂度  O(nlogn)</li></ul><p>快速排序的问题：</p><ul><li>最坏情况  （一个倒序的列表的时间复杂度是O（n²））</li><li>递归</li></ul><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nsis">def quick_sort(li, <span class="hljs-literal">left</span>, <span class="hljs-literal">right</span>):<br>    if <span class="hljs-literal">left</span> &lt; <span class="hljs-literal">right</span>: <span class="hljs-comment"># 至少两个元素</span><br>        mid = partition(li, <span class="hljs-literal">left</span>, <span class="hljs-literal">right</span>)<br>        quick_sort(li, <span class="hljs-literal">left</span>, mid - <span class="hljs-number">1</span>)<br>        quick_sort(li, mid + <span class="hljs-number">1</span>, <span class="hljs-literal">right</span>)<br>        <span class="hljs-keyword">return</span> li<br><br>def partition(li, <span class="hljs-literal">left</span>, <span class="hljs-literal">right</span>):<br>    tmp = li[<span class="hljs-literal">left</span>]<br>    while <span class="hljs-literal">left</span> &lt; <span class="hljs-literal">right</span>:<br>        while li[<span class="hljs-literal">right</span>] &gt;= tmp and <span class="hljs-literal">left</span> &lt; <span class="hljs-literal">right</span>:  <span class="hljs-comment"># 从右边找比tmp小的数</span><br>            <span class="hljs-literal">right</span> -= <span class="hljs-number">1</span>  <span class="hljs-comment"># 左走一步</span><br>        li[<span class="hljs-literal">left</span>] = li[<span class="hljs-literal">right</span>]  <span class="hljs-comment"># 把右边比tmp小的数放到左边</span><br>        while li[<span class="hljs-literal">left</span>] &lt;= tmp and <span class="hljs-literal">left</span> &lt; <span class="hljs-literal">right</span>:<br>            <span class="hljs-literal">left</span> += <span class="hljs-number">1</span><br>        li[<span class="hljs-literal">right</span>] = li[<span class="hljs-literal">left</span>]  <span class="hljs-comment"># 把左边的值写到右边</span><br>    li[<span class="hljs-literal">left</span>] = tmp  <span class="hljs-comment"># 把tmp归位</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">left</span><br><br><br>li = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br>s = quick_sort(li,<span class="hljs-number">0</span>,len(li)-<span class="hljs-number">1</span>)<br><span class="hljs-literal">print</span>(s)<br></code></pre></td></tr></table></figure><h3 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5. 堆排序"></a><strong>5. 堆排序</strong></h3><p>堆：一种特殊的完全二叉树结构</p><ul><li>大根堆：一颗完全二叉树，满足任一节点都比其孩子节点大</li><li>小根堆：一颗完全二叉树，满足任一节点都比其他孩子节点小</li></ul><p>堆的向下调整：当根节点的左右子树都是堆时，可以通过一次向下的调整来将其变成一个堆</p><p>堆排序过程：</p><p>1.建立堆</p><p>2.得到堆顶元素，为最大元素</p><p>3.去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序</p><p>4.堆顶元素为第二大元素</p><p>5.重复步骤3，直到堆边空</p><p>堆排序–topk问题</p><p>现在有n个数，设计算法得到前k大的数。（k&lt;n）</p><p>解决思路：</p><p>1.排序后切片  O(nlogn)</p><p>2.排序LOWB三人组  O(kn)</p><p>3.堆排序思路  O(nlogk)</p><h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h3><h3 id="7-其他排序"><a href="#7-其他排序" class="headerlink" title="7. 其他排序"></a>7. 其他排序</h3><ul><li>希尔排序</li><li>计数排序</li><li>基数排序</li></ul><h1 id="第三章：数据结构"><a href="#第三章：数据结构" class="headerlink" title="第三章：数据结构"></a>第三章：数据结构</h1><p>数据结构：数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。简单来说，数据结构就是设计数据以何种方式组织并存储在计算机中。</p><p>比如：python入门时的列表、字典、集合等都是一种数据结构。</p><p><strong>程序 &#x3D; 数据结构 + 算法</strong></p><p>数据结构的分类(按照其逻辑结构分)：</p><ul><li>线性结构：数据结构中的元素存在一对一的相互关系</li><li>树结构：数据结构中的元素存在一对多的相互关系</li><li>图结构：数据结构中的元素存在多对多的相互关系</li></ul><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h2 id="3-1-列表"><a href="#3-1-列表" class="headerlink" title="3.1 列表"></a>3.1 列表</h2><p>其他语言称为数组，是一种基本数据类型。</p><p>数组和列表的区别：</p><p>1.数组元素类型要相同</p><p>2.数组长度要固定</p><hr><ul><li>列表是顺序存储的？</li><li>列表的基本操作？<ul><li>按下标查找  li[2]</li><li>获取指定元素的索引  li.index(‘2’)</li><li>插入元素 li.append(‘2’)  li.extend(‘2’)  li.insert(2,’2’)</li><li>删除元素  li.remove(‘2’)  li.pop(2)</li></ul></li><li>这些操作的时间复杂度是多少？<ul><li>append是O(1)</li><li>insert、pop、remove都是是O(n)</li></ul></li></ul><p>扩展：python的列表是如何实现的？</p><h2 id="3-2-栈-Stack"><a href="#3-2-栈-Stack" class="headerlink" title="3.2 栈(Stack)"></a>3.2 栈(Stack)</h2><p>栈（Stack）是一种数据集合，可以理解为只能在一端进行插入或删除操作的列表。</p><p>栈的特点：后进先出LIFO(last-in,first-out)</p><p>栈的概念：栈顶、栈底</p><p>栈的基本操作：</p><ul><li>进栈（压栈）：push</li><li>出栈：pop</li><li>取栈顶：gettop</li></ul><p><img src="/../imgs/1680333686740.png" alt="1680333686740"></p><hr><p>使用一般的列表结构即可实现栈：</p><ul><li>进栈：li.append()</li><li>出栈：li.pop()</li><li>取栈顶：li[-1]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.stack = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, element</span>):  <span class="hljs-comment"># 进栈</span><br>        <span class="hljs-keyword">return</span> self.stack.append(element)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 出栈</span><br>        <span class="hljs-keyword">return</span> self.stack.pop(-<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gettop</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 去栈顶</span><br>        <span class="hljs-keyword">if</span> self.stack != []:<br>            <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.stack<br><br><br>stack = Stack()<br>stack.push(<span class="hljs-number">1</span>)<br>stack.push(<span class="hljs-number">2</span>)<br>stack.push(<span class="hljs-number">3</span>)<br><span class="hljs-comment"># print(stack.pop())</span><br><span class="hljs-built_in">print</span>(stack.get())<br></code></pre></td></tr></table></figure><hr><p><strong>栈的经典应用</strong> – <strong>括号匹配问题</strong></p><p>括号匹配问题：给一个字符串，其中包括小括号、中括号、大括号，求该字符串中的括号是否匹配。</p><p>例如：（[{}]）是匹配的。      ｛()] 是不匹配的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">brack_match</span>(<span class="hljs-params">s</span>):<br>    li = []<br>    dic = &#123;<span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br>        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> &#123;<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>&#125;:<br>            li.append(i)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(li) == <span class="hljs-number">0</span>: <span class="hljs-comment"># 需要先判断&#x27;)&#x27;这种类似情况</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">elif</span> dic[i] == li[-<span class="hljs-number">1</span>]: <span class="hljs-comment"># 再判断是不是和前一个匹配</span><br>                li.pop()<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># dic[i] != li[-1]</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># 判断&#x27;(&#x27;这种类似情况</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(li) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="3-3-队列-Queue"><a href="#3-3-队列-Queue" class="headerlink" title="3.3 队列(Queue)"></a>3.3 队列(Queue)</h2><p>队列（Queue）是一个数据集合，仅允许在列表的一端进行插入，另一端进行删除。</p><ul><li>进行插入的一端称为队尾（rear），插入动作称为进队或入队</li><li>进行删除的一端称为队头（front），删除动作称为出队</li><li>队列的性质：先进先出（first-in，first-out）</li></ul><p><img src="/../imgs/1675586589007.png" alt="1675586589007"></p><p><strong>队列的实现方式 – 环形队列</strong></p><p><img src="/../imgs/1675589944446.png" alt="1675589944446"></p><p>环形对列：当指针front &#x3D;&#x3D; maxsize - 1时，再前进一个位置就自动到0。</p><ul><li>队首指针前进1：front &#x3D; (front+1) % maxsize</li><li>队尾指针前进1：rear &#x3D; (rear+1) % maxsize</li><li>队空条件：rear &#x3D;&#x3D; front</li><li>队满条件： （rear+1） % maxsize &#x3D;&#x3D; front</li></ul><p>自己写代码实现环形队列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, size=<span class="hljs-number">100</span></span>):<br>        self.queue = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]<br>        self.size = size<br>        self.rear = <span class="hljs-number">0</span>  <span class="hljs-comment"># 队尾指针</span><br>        self.front = <span class="hljs-number">0</span>  <span class="hljs-comment"># 队首指针</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, element</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_filled():<br>            self.rear = (self.rear + <span class="hljs-number">1</span>) % self.size<br>            self.queue[self.rear] = element<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;queue is filled&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_empty():<br>            self.front = (self.front + <span class="hljs-number">1</span>) % self.size<br>            <span class="hljs-keyword">return</span> self.queue[self.front]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&#x27;queue is empty&#x27;</span>)<br><br>    <span class="hljs-comment"># 判断队空</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.rear == self.front<br><br>    <span class="hljs-comment"># 判断队满</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_filled</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (self.rear + <span class="hljs-number">1</span>) % self.size == self.front<br><br><br>q = Queue(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    q.push(i)<br><br><span class="hljs-built_in">print</span>(q.pop())<br>q.push(<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(q.is_filled())<br></code></pre></td></tr></table></figure><p><strong>双向队列</strong></p><p>双向队列的两端都支持进队和出队操作</p><ul><li>队首进队</li><li>队首出队</li><li>队尾进队</li><li>队尾出队</li></ul><p><img src="/../imgs/1675612543077.png" alt="1675612543077"></p><p>python中内置的队列模块</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> collections import deque<br><br><span class="hljs-attribute">q</span> = deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>)<br><span class="hljs-comment"># 单向队列</span><br><span class="hljs-attribute">q</span>.append(<span class="hljs-number">5</span>)  # 队尾进队<br><span class="hljs-attribute">q</span>.popleft()  # 队首进队<br><br><span class="hljs-comment"># 用于双向队列</span><br><span class="hljs-attribute">q</span>.appendleft(<span class="hljs-number">7</span>)  # 队首进队<br><span class="hljs-attribute">q</span>.pop()  # 队尾出队<br></code></pre></td></tr></table></figure><p>可以用队列大致实现linux中tail命令（输出最后几行文本）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tail</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-comment">#  主要依赖python中的队列，队满之后再入队，前面就出队，所以全部入队后就剩最后n个数据</span><br>        q = deque(f, n)<br>        <span class="hljs-keyword">return</span> q<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tail(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><h4 id="方法一：栈-–-深度优先搜索-DFS"><a href="#方法一：栈-–-深度优先搜索-DFS" class="headerlink" title="方法一：栈 – 深度优先搜索 DFS"></a>方法一：栈 – 深度优先搜索 DFS</h4><ul><li>回溯法</li><li>思路：从一个节点开始，任意找下一个能走的点，当找不到能走的点时，退回上一个点寻找是否有其他方向的点。</li><li>使用栈存储当前路径</li></ul><p><img src="/../imgs/1682264942618.png" alt="1682264942618"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python">maze = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>]<br><br>dirs = [<br>    <span class="hljs-keyword">lambda</span> x, y: (x - <span class="hljs-number">1</span>, y),<br>    <span class="hljs-keyword">lambda</span> x, y: (x, y + <span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">lambda</span> x, y: (x + <span class="hljs-number">1</span>, y),<br>    <span class="hljs-keyword">lambda</span> x, y: (x, y - <span class="hljs-number">1</span>)<br>]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maze_path</span>(<span class="hljs-params">x1, y1, x2, y2</span>):<br>    stack = []<br>    stack.append((x1, y1))<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span>:<br>        curNode = stack[-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 当前节点</span><br>        <span class="hljs-comment"># 走到终点了</span><br>        <span class="hljs-keyword">if</span> curNode[<span class="hljs-number">0</span>] == x2 <span class="hljs-keyword">and</span> curNode[<span class="hljs-number">1</span>] == y2:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> stack:<br>                <span class="hljs-built_in">print</span>(i)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-comment"># x,y四个方向：上右下左 (x-1,y);(x,y+1);(x+1,y);(x,y-1);</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">dir</span> <span class="hljs-keyword">in</span> dirs:<br>            nextNode = <span class="hljs-built_in">dir</span>(curNode[<span class="hljs-number">0</span>], curNode[<span class="hljs-number">1</span>])<br>            <span class="hljs-comment"># 如果下个节点能走</span><br>            <span class="hljs-keyword">if</span> maze[nextNode[<span class="hljs-number">0</span>]][nextNode[<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>:<br>                stack.append(nextNode)<br>                maze[nextNode[<span class="hljs-number">0</span>]][nextNode[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>  <span class="hljs-comment"># 标记走过的点为2，有没有必要后面再想</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            maze[nextNode[<span class="hljs-number">0</span>]][nextNode[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span><br>            stack.pop()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;没有路！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br>maze_path(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>​</p><h4 id="方法二：队列-–-广度优先搜索-BFS"><a href="#方法二：队列-–-广度优先搜索-BFS" class="headerlink" title="方法二：队列 – 广度优先搜索 BFS"></a>方法二：队列 – 广度优先搜索 BFS</h4><ul><li>思路：从一个节点开始，寻找所有接下来能继续走的点，继续不断寻找，知道找到出口</li><li>使用队列存储当前正在考虑的节点</li></ul><p><img src="/../imgs/1683793807805.png" alt="1683793807805"></p><p>还需要一个队列来往回找走到终点的的路径，该路径为最短路径</p><table><thead><tr><th align="center">出队序列下标</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th></tr></thead><tbody><tr><td align="center">出队序列</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td></tr><tr><td align="center">让它来的下标</td><td align="center">-1</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">2</td><td align="center">3</td><td align="center">4</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>maze = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>]<br><br>dirs = [<br>    <span class="hljs-keyword">lambda</span> x, y: (x - <span class="hljs-number">1</span>, y),<br>    <span class="hljs-keyword">lambda</span> x, y: (x, y + <span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">lambda</span> x, y: (x + <span class="hljs-number">1</span>, y),<br>    <span class="hljs-keyword">lambda</span> x, y: (x, y - <span class="hljs-number">1</span>)<br>]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_r</span>(<span class="hljs-params">path</span>):<br>    curNode = path[-<span class="hljs-number">1</span>]<br>    realpath = []<br>    <span class="hljs-keyword">while</span> curNode[<span class="hljs-number">2</span>] != -<span class="hljs-number">1</span>:<br>        realpath.append(curNode[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])<br>        curNode = path[curNode[<span class="hljs-number">2</span>]]<br>    realpath.append(curNode[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])  <span class="hljs-comment"># 起点</span><br>    realpath.reverse()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> realpath:<br>        <span class="hljs-built_in">print</span>(i)<br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maze_path_queue</span>(<span class="hljs-params">x1, y1, x2, y2</span>):<br>    queue = deque()<br>    queue.append((x1, y1, -<span class="hljs-number">1</span>))<br>    path = []<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>:<br>        curNode = queue.popleft()  <span class="hljs-comment"># 当前节点出队</span><br>        path.append(curNode)<br>        <span class="hljs-comment"># 判断终点</span><br>        <span class="hljs-keyword">if</span> curNode[<span class="hljs-number">0</span>] == x2 <span class="hljs-keyword">and</span> curNode[<span class="hljs-number">1</span>] == y2:<br>            print_r(path)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-comment"># 后面节点入队</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">dir</span> <span class="hljs-keyword">in</span> dirs:<br>            nextNode = <span class="hljs-built_in">dir</span>(curNode[<span class="hljs-number">0</span>], curNode[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">if</span> maze[nextNode[<span class="hljs-number">0</span>]][nextNode[<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>:<br>                queue.append((nextNode[<span class="hljs-number">0</span>], nextNode[<span class="hljs-number">1</span>], <span class="hljs-built_in">len</span>(path) - <span class="hljs-number">1</span>))  <span class="hljs-comment"># 后续节点进队，记录那个节点带它来的</span><br>                maze[nextNode[<span class="hljs-number">0</span>]][nextNode[<span class="hljs-number">1</span>]] = <span class="hljs-number">2</span>  <span class="hljs-comment"># 标记为已经走过</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;没有路&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br>maze_path_queue(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h2 id="3-4-链表"><a href="#3-4-链表" class="headerlink" title="3.4 链表"></a>3.4 链表</h2><p>链表是由一系列节点组成的元素集合。每个节点包含两部分，数据域item和指向下一个节点的指针next。通过节点之间的相互连接，最终串联成一个链表。</p><p><strong>创建链表</strong></p><ul><li><p>头插法</p><p><img src="/../imgs/1683873719103.png" alt="1683873719103"></p></li><li><p>尾插法</p><p><img src="/../imgs/1683873738638.png" alt="1683873738638"></p></li></ul><p><strong>链表与顺序表(列表&#x2F;数组)</strong></p><ul><li>链表在插入和删除的操作明显快于顺序表</li><li>链表的内存可以更灵活的分配<ul><li>可以尝试利用链表重新实现栈和队列</li></ul></li><li>链表这种链式存储的数据结构对数和图结构有很大的启发性</li></ul><h2 id="3-5-哈希表-Hash-Table"><a href="#3-5-哈希表-Hash-Table" class="headerlink" title="3.5 哈希表(Hash Table)"></a>3.5 哈希表(Hash Table)</h2><p>通过哈希函数来计算数据存储位置的数据结构，通常支持如下操作：</p><ul><li>insert(key,value): 插入键值对</li><li>get(key): 如果存在键为key的键值对则返回value，否则返回空值</li><li>delete(key): 删除键为key的键值对</li></ul><hr><p><img src="/../imgs/1683877448486.png" alt="1683877448486"></p><p><strong>直接寻址表缺点</strong></p><ul><li>当域U很大时，需要消耗大量内存，很不实际</li><li>如果域很大，而实际出现的key很少，则大量空间被浪费</li><li>无法处理关键字不是数字的情况</li></ul><p><strong>哈希</strong></p><p>直接寻址表：key为k的元素放到k位置上</p><p>改进直接寻址表：哈希（Hashing）</p><ul><li>构建大小为m的寻址表T</li><li>key为k的元素放到h(k)上</li><li>h(k)时一个函数，其将域U映射到表T[0,1,…,m-1]</li></ul><p>哈希表 (又称散列表)，是一种线性表的存储结构。哈希表由一个<strong>直接寻址表</strong>和<strong>哈希函数</strong>组成，哈希函数h(k)将元素关键字k作为自变量，返回元素的存储下标。</p><p>假设有一个长度为7的哈希表，哈希函数h(k) &#x3D; k%7。元素集合{14，22，3，5}的存储方式如下图。</p><p><img src="/../imgs/1683877878041.png" alt="1683877878041"></p><hr><p><strong>哈希冲突</strong></p><p>由于哈希表的大小是有限的，而要存储的值的总数量是无线的，因此对于任何哈希函数，都会出现两个不同元素映射到同一个位置上的情况，这种情况叫做哈希冲突。</p><p>例如：h(k)&#x3D;k%7，h(0) &#x3D; h(7) &#x3D; h(14) &#x3D; … </p><p>解决哈希冲突：</p><ul><li><p>开放寻址法：如果哈希函数返回的位置已经有值，则可以向后探查新的位置来存储这个值。</p><ul><li>线性探查：如果位置i被占用，则探查i+1，i+2，…</li><li>二次探查：如果位置i被占用，则探查i+1²，i-1²，i+2²，i-2²…</li><li>二度哈希：有n个哈希函数，当使用第一个哈希函数h1发生冲突时，则尝试使用h2，h3…</li></ul></li><li><p>拉链法（比较常用的方法）</p><p>哈希表每个位置都连接一个链表，当冲突发生时，冲突的元素将被加到该位置链表的最后。</p><p><img src="/../imgs/1683878880346.png" alt="1683878880346"></p></li></ul><p>常见的哈希函数</p><ul><li><p>除法哈希法(比较常见的)</p><p>h(k) &#x3D; k % m</p></li><li><p>乘法哈希法</p></li><li><p>全域哈希法</p></li></ul><hr><p><strong>哈希表的应用</strong> </p><ul><li><p>集合{} 和 字典{}</p><p><img src="/../imgs/1683968841075.png" alt="1683968841075"></p></li><li><p>md5算法</p><p><img src="/../imgs/1683968875380.png" alt="1683968875380"></p><p><img src="/../imgs/1683968934570.png" alt="1683968934570"></p></li><li><p>SHA2算法</p><p><img src="/../imgs/1683969090169.png" alt="1683969090169"></p></li></ul><p>​</p><h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><h2 id="3-6-树与二叉树"><a href="#3-6-树与二叉树" class="headerlink" title="3.6 树与二叉树"></a>3.6 树与二叉树</h2><ul><li>树是一种数据结构     比如：目录结构</li><li>树是一种可以递归定义的数据结构</li><li>树是由n个节点组成的集合<ul><li>如果n&#x3D;0，那这是一颗空树</li><li>如果n&gt;0，那存在一个节点作为树的根节点，其他节点又可以分为m个集合，每个集合本身又是一棵树</li></ul></li></ul><p><img src="/../imgs/1684482649695.png" alt="1684482649695"></p><p><strong>相关概念</strong></p><ul><li>根节点(A)、叶子节点(不能分叉的节点，BCHIPQKLMN都是叶子节点)</li><li>树的深度（高度）（最深有几层，此处为4层）</li><li>树的度：所有节点最大的度，为该树的度，例如该图的树的度为6<ul><li>节点的度：看分了几个叉，例如节点E的度是2，节点F的度是3</li></ul></li><li>孩子节点、父节点：节点之间的关系，例如A是B的父节点，B是A的子节点</li><li>子树：EIJPQ就是一个子树</li></ul><h3 id="3-6-1-二叉树"><a href="#3-6-1-二叉树" class="headerlink" title="3.6.1 二叉树"></a><strong>3.6.1 二叉树</strong></h3><ul><li>度不超过2的树</li><li>每个节点最多有两个孩子节点</li><li>两个孩子节点被区分为左孩子节点和右孩子节点</li></ul><p>解题过程中两种最主要的形式：</p><p><strong>满二叉树</strong>：一个二叉树，如果每一层的节点数都达到最大值，则这个二叉树是满二叉树（图a）；深度为k，有2^k-1个节点的二叉树。</p><p><strong>完全二叉树</strong>：叶节点只能出现在最下层和次下层，并且最下面一层的节点都集中在该层最左边的若干位置的二叉树。(可以理解为最下一层可以不满，但是，最下层的节点必须优先排左边，例如图b)；若最底层为h层，则该层包含1~2^(h-1)个节点。</p><p>堆就是一个完全二叉树，同时保证父子节点的顺序关系。</p><p><img src="/../imgs/1678018167762.png" alt="1678018167762"></p><p><strong>二叉搜索树</strong></p><p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p></li><li><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p></li><li><p>它的左、右子树也分别为二叉排序树</p><p><img src="/../imgs/1684564655291.png" alt="1684564655291"></p></li></ul><p><strong>平衡二叉搜索树</strong></p><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p><img src="/../imgs/1684564713122.png" alt="1684564713122"></p><p><strong>二叉树的存储方式（表示方式）</strong></p><ul><li><p>链式存储方式（指针）</p><p>将二叉树的节点定义为一个对象，节点之间通过类似链表的连接方式来连接</p></li><li><p>顺序存储方式（数组）</p><p>1.通过父节点找孩子节点：</p><p><img src="/../imgs/1678018569644.png" alt="1678018569644"></p><p>2.通过孩子节点找父节点 ： i &#x3D; (i - 1) &#x2F;&#x2F; 2</p></li></ul><p><strong>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</strong></p><p><strong>二叉树的遍历</strong></p><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ol><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，只要大家记住 前中后序指的就是中间节点的位置就可以了。</p><p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>大家可以对着如下图，看看自己理解的前后中序有没有问题。</p><p><img src="/../imgs/20200806191109896.png" alt="img"></p><p><strong>二叉树的定义</strong>（链式存储）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p><strong>前后中序的递归写法三要素</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><br><span class="hljs-comment"># 前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution1</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>):<br>        res = []  <span class="hljs-comment"># 保存结果</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">traversal</span>(<span class="hljs-params">root: TreeNode</span>):<br>            <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br>            res.append(root.value)  <span class="hljs-comment"># 前序</span><br>            traversal(root.left)  <span class="hljs-comment"># 左</span><br>            traversal(root.right)  <span class="hljs-comment"># 右</span><br><br>        traversal(root)<br>        <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-comment"># 中序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution2</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>):<br>        res = []  <span class="hljs-comment"># 保存结果</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">traversal</span>(<span class="hljs-params">root: TreeNode</span>):<br>            <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br><br>            traversal(root.left)  <span class="hljs-comment"># 左</span><br>            res.append(root.value)  <span class="hljs-comment"># 中序</span><br>            traversal(root.right)  <span class="hljs-comment"># 右</span><br><br>        traversal(root)<br>        <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-comment"># 后序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution3</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root: TreeNode</span>):<br>        res = []  <span class="hljs-comment"># 保存结果</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">traversal</span>(<span class="hljs-params">root: TreeNode</span>):<br>            <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br><br>            traversal(root.left)  <span class="hljs-comment"># 左</span><br>            traversal(root.right)  <span class="hljs-comment"># 右</span><br>            res.append(root.value)  <span class="hljs-comment"># 后序</span><br><br>        traversal(root)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第四章：算法进阶"><a href="#第四章：算法进阶" class="headerlink" title="第四章：算法进阶"></a>第四章：算法进阶</h1><h2 id="4-1-贪心算法"><a href="#4-1-贪心算法" class="headerlink" title="4.1 贪心算法"></a>4.1 贪心算法</h2><p>局部最优 –&gt; 全局最优</p><ul><li>又称贪婪算法，是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的是在某种意义上的局部最优解。</li><li>贪心算法并不能保证得到最优解，但是在某些问题上贪心算法的解就是最优解。要会判断一个问题是否能用贪心算法来计算。</li></ul><p><strong>典型例题：</strong></p><ol><li>找零问题</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">n</span>):<br>    m = [<span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>]<br>    money = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(m)<br>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(m):<br>        money[i] = n // j<br>        n = n % j<br>    <span class="hljs-keyword">return</span> money<br><br><br><span class="hljs-built_in">print</span>(change(<span class="hljs-number">999</span>))<br><span class="hljs-comment"># 结果 [9, 1, 2, 0, 1, 4]</span><br></code></pre></td></tr></table></figure><ol start="2"><li>接最大数字</li></ol><p><a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993">https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993</a>?</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe">tpId=<span class="hljs-number">13</span>&amp;tqId=<span class="hljs-number">11185</span>&amp;ru=/exam/oj<br><br><span class="hljs-meta"># s = &#x27;32,94,128,1286,6,71&#x27;</span><br>s = [<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">321</span>]<br><span class="hljs-keyword">new</span><span class="hljs-type">_s</span> = list(map(str, s))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(<span class="hljs-keyword">new</span><span class="hljs-type">_s</span>) - <span class="hljs-number">1</span>):<span class="hljs-type"></span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(<span class="hljs-keyword">new</span><span class="hljs-type">_s</span>) - i - <span class="hljs-number">1</span>):<span class="hljs-type"></span><br>        <span class="hljs-meta"># 一个冒泡排序的思维，前后比较，如果后+前小于&lt;前+后，就换交换两个位置</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j] + <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j + <span class="hljs-number">1</span>] &gt; <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j + <span class="hljs-number">1</span>] + <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j]:<span class="hljs-type"></span><br>            <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j], <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j + <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j + <span class="hljs-number">1</span>], <span class="hljs-keyword">new</span><span class="hljs-type">_s</span>[j]<br><br>print(<span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-keyword">new</span><span class="hljs-type">_s</span>))<br></code></pre></td></tr></table></figure><ol start="3"><li>活动选择问题</li></ol><p><img src="/../imgs/1685421573606.png" alt="1685421573606"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 贪心结论：最先结束的活动一定是最优解的一部分</span><br><span class="hljs-attribute">def</span> solution(activities):<br><span class="hljs-comment"># 按结束时间排序</span><br>    <span class="hljs-attribute">activities</span>.sort(key=lambda x: x[<span class="hljs-number">1</span>])<br>    <span class="hljs-attribute">res</span> =<span class="hljs-meta"> [activities[0]]</span><br>    <span class="hljs-attribute">for</span> i in range(<span class="hljs-number">1</span>, len(activities)):<br>        <span class="hljs-comment"># 当前活动的开始时间小于等于最后一个入选活动的结束时间</span><br>        <span class="hljs-attribute">if</span> activities[i][<span class="hljs-number">0</span>] &gt;= res[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:<br>            <span class="hljs-attribute">res</span>.append(activities[i])<br><br>    <span class="hljs-attribute">return</span> res<br><br><br><span class="hljs-attribute">activities</span> =<span class="hljs-meta"> [(1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16)]</span><br><span class="hljs-attribute">print</span>(solution(activities))<br></code></pre></td></tr></table></figure><ol start="4"><li><p>区间问题</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">   <br></code></pre></td></tr></table></figure></li></ol><h2 id="4-2-背包问题"><a href="#4-2-背包问题" class="headerlink" title="4.2 背包问题"></a>4.2 背包问题</h2><p>一个小偷在某个商店发现有n个商品，第i个商品价值vi，重wi。他希望拿走的价值最大，但他的背包只能容纳w千克的东西。他应该拿走那些商品?</p><ul><li><p>01背包（动态规划）</p><p>对于一个商品要么完整拿走，要么留下。不能只拿走一部分，或把一个商品多次拿走。</p></li><li><p>分数背包 (贪心算法)</p><p>可以拿走一部分（金砂）</p></li></ul><h2 id="4-3-动态规划"><a href="#4-3-动态规划" class="headerlink" title="4.3 动态规划"></a>4.3 动态规划</h2><p>建议直接看代码随想录：<a href="https://www.programmercarl.com/">https://www.programmercarl.com/</a></p><p>求最优解的问题，有些使用贪心算法无法得到正确答案，可以尝试动态规划。</p><p><strong>对于动态规划问题五步曲：</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>从斐波那契数列了解动态规划</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 递归写斐波那契数列</span><br><span class="hljs-comment"># 递归计算很慢，这里是由于子问题的重复计算</span><br><span class="hljs-attribute">def</span> fib1(n):<br>    <span class="hljs-attribute">if</span> n == <span class="hljs-number">1</span> or n == <span class="hljs-number">2</span>:<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-attribute">else</span>:<br>        <span class="hljs-attribute">return</span> fib1(n - <span class="hljs-number">1</span>) + fib1(n - <span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># 非递归写</span><br><span class="hljs-comment"># 这里就类似动态规划的思想DP ：递推式+重复子问题</span><br><span class="hljs-attribute">def</span> fib2(n):<br>    <span class="hljs-attribute">res</span> =<span class="hljs-meta"> [0, 1, 1]</span><br>    <span class="hljs-attribute">for</span> i in range(n - <span class="hljs-number">2</span>):<br>        <span class="hljs-attribute">if</span> n &gt; <span class="hljs-number">2</span>:<br>            <span class="hljs-attribute">res</span>.append(res[-<span class="hljs-number">1</span>] + res[-<span class="hljs-number">2</span>])<br><br>    <span class="hljs-attribute">return</span> res[n]<br><br><br><span class="hljs-attribute">print</span>(fib1(<span class="hljs-number">100</span>), fib2(<span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure><p><strong>典型例题</strong></p><ol><li><p>钢条切割问题</p></li><li><p>最长公共子序列</p></li></ol><h2 id="4-4-滑动窗口法"><a href="#4-4-滑动窗口法" class="headerlink" title="4.4 滑动窗口法"></a>4.4 滑动窗口法</h2><p>和双指针很类似</p><p>关键词：</p><ul><li>满足xx条件（计算结果，出现次数，同时包含）</li><li>最长&#x2F;最短</li><li>子串&#x2F;子数组&#x2F;子序列</li></ul><p>例如：长度最小的子数组 </p><p>使用思路1：（寻找最长）</p><p><strong>核心：左右双指针（L,R）在起始点，R向右逐位滑动循环</strong></p><p>每次滑动过程中：</p><p>如果：窗内元素满足条件，R向右扩大窗口，并更新最优结果</p><p>如果：窗内元素不满足条件，L向右缩小窗口</p><p>直到R到达结尾</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 最长模板</span><br>s = input()<br>left = <span class="hljs-number">0</span>  <span class="hljs-comment"># 左指针</span><br><span class="hljs-literal">right</span> = <span class="hljs-number">0</span>  <span class="hljs-comment"># 右指针</span><br>max_len = <span class="hljs-number">0</span> <span class="hljs-comment">#</span><br><span class="hljs-comment"># 右指针没有到末尾</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">right</span> &lt; <span class="hljs-built_in">len</span>(s):<br>    <span class="hljs-keyword">while</span> (不满足要求):<br>        <span class="hljs-comment"># 左指针移动</span><br>        left += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 更新最优结果</span><br>    max_len = <span class="hljs-built_in">max</span>(max_len, <span class="hljs-literal">right</span> - left + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 右指针移动</span><br>    <span class="hljs-literal">right</span> += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 更新结果和右指针移动可以换位置，更新结果就不用+1了</span><br></code></pre></td></tr></table></figure><p>使用思路2：（寻找最短）</p><p><strong>核心：左右双指针（L,R）在起始点，R向右逐位滑动循环</strong></p><p>每次滑动过程中：</p><p>如果：窗内元素满足条件，L向右缩小窗口，并更新最优结果</p><p>如果：窗内元素不满足条件，R向右扩大窗口</p><p>直到R到达结尾</p><p><img src="/../imgs/1685001293715.png" alt="1685001293715"></p><h2 id="4-5-双指针"><a href="#4-5-双指针" class="headerlink" title="4.5 双指针"></a>4.5 双指针</h2><p>1.反转字符串</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">s = <span class="hljs-string">&quot;abcdefg&quot;</span><br><br>s = <span class="hljs-built_in">list</span>(s)<br><span class="hljs-attribute">left</span> = <span class="hljs-number">0</span><br><span class="hljs-attribute">right</span> = <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>while <span class="hljs-attribute">left</span> &lt; <span class="hljs-built_in">len</span>(s) // <span class="hljs-number">2</span>:<br>    s<span class="hljs-selector-attr">[left]</span>, s<span class="hljs-selector-attr">[right]</span> = s<span class="hljs-selector-attr">[right]</span>, s<span class="hljs-selector-attr">[left]</span><br>    <span class="hljs-attribute">left</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">right</span> -= <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s)</span></span><br></code></pre></td></tr></table></figure><h2 id="4-6-约瑟夫环问题"><a href="#4-6-约瑟夫环问题" class="headerlink" title="4.6 约瑟夫环问题"></a>4.6 约瑟夫环问题</h2><p>也叫丢手绢问题</p><p>剑指 Offer 62. 圆圈中最后剩下的数字</p><p><a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 思路1：leecode会超时</span><br>n, m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>()), <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>date = []<br>deldate = []<br><span class="hljs-comment"># 所有数据存入date</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    date.append(i)<br>num = <span class="hljs-number">0</span><br><span class="hljs-comment"># 循环 date只有一个数据时停止，此时说明只剩一个数据，符合题意</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(date) &gt; <span class="hljs-number">1</span>:<br>    num += <span class="hljs-number">1</span><br><span class="hljs-comment"># temp = date[0] 先删除，如果是第三个就直接删除了，如果不是第三个就在date末尾添加上，保证一次只删除第三个</span><br>    temp = date.pop(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> num == m:<br>        deldate.append(temp)<br>        num = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        date.append(temp)<br><br><span class="hljs-built_in">print</span>(date[<span class="hljs-number">0</span>])<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 思路2：动态规划--&gt;状态转移方程推理过程没搞明白，先记住</span><br>n, m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>()), <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n, m</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> (solution(n - <span class="hljs-number">1</span>, m) + m) % n<br><br><span class="hljs-built_in">print</span>(solution(n,m))<br></code></pre></td></tr></table></figure><h2 id="4-7-回溯算法"><a href="#4-7-回溯算法" class="headerlink" title="4.7 回溯算法"></a>4.7 回溯算法</h2><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>回溯算法模板框架：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数) &#123;<br>    if (终止条件) &#123;<br>        存放结果;<br>        return;<br>    &#125;<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回溯法三部曲：</p><ul><li>递归函数的返回值以及参数</li><li>回溯函数终止条件</li><li>单层搜索的过程</li></ul><ol><li><p>组合问题</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vim">nums = <span class="hljs-string">&#x27;abc&#x27;</span><br>n = <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">k</span> = <span class="hljs-number">2</span><br><br><br>def permutation(<span class="hljs-keyword">k</span>, nums):<br>    <span class="hljs-keyword">res</span> = []  # 符合条件的结果集<br>    backtracking(<span class="hljs-keyword">k</span>, <span class="hljs-number">0</span>, [], <span class="hljs-keyword">res</span>)<br>    <span class="hljs-keyword">new</span> = [<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-keyword">join</span>(i) <span class="hljs-keyword">for</span> i in <span class="hljs-keyword">res</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><br><br><br># start_index集合从哪里开始遍历,防止出现重复的组合。<br>def backtracking(<span class="hljs-keyword">k</span>, start_index, path, <span class="hljs-keyword">res</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-keyword">k</span>:<br>        <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(path[:])<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(start_index, n):<br>        path.<span class="hljs-keyword">append</span>(nums[i])<br>        backtracking(<span class="hljs-keyword">k</span>, i + <span class="hljs-number">1</span>, path, <span class="hljs-keyword">res</span>)<br>        path.<span class="hljs-keyword">pop</span>()<br><br><br><span class="hljs-keyword">print</span>(permutation(<span class="hljs-keyword">k</span>, nums))<br><br></code></pre></td></tr></table></figure></li><li><p>子集问题</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">s = <span class="hljs-string">&#x27;123&#x27;</span><br>def permutations(s):<br>    <span class="hljs-keyword">res</span> = []<br>    backtracking(s, <span class="hljs-number">0</span>, [], <span class="hljs-keyword">res</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br><br><br>def backtracking(s, start_index, path, <span class="hljs-keyword">res</span>):<br>    <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(path[:])<br>    <span class="hljs-keyword">if</span> start_index&gt;<span class="hljs-built_in">len</span>(s):<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(start_index,<span class="hljs-built_in">len</span>(s)):<br>        path.<span class="hljs-keyword">append</span>(s[i])<br>        backtracking(s, i + <span class="hljs-number">1</span>, path, <span class="hljs-keyword">res</span>)<br>        path.<span class="hljs-keyword">pop</span>()<br><br><span class="hljs-keyword">print</span>(permutations(s))<br><br></code></pre></td></tr></table></figure></li><li><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">   <br></code></pre></td></tr></table></figure></li><li><p>全排列</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vim">from itertools import permutations<br><br>nums = <span class="hljs-string">&#x27;abc&#x27;</span><br># 方法一：直接用permutations<br>ans = <span class="hljs-keyword">list</span>(permutations(nums))<br>ans = [<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-keyword">join</span>(i) <span class="hljs-keyword">for</span> i in ans]<br><span class="hljs-keyword">print</span>(ans)<br><br><br># 方法二：递归+回溯<br>def permutation(nums):<br>    <span class="hljs-keyword">res</span> = []  # 结果集<br>    backtracking(nums, [], <span class="hljs-keyword">res</span>)<br>    <span class="hljs-keyword">res</span> = [<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-keyword">join</span>(i) <span class="hljs-keyword">for</span> i in <span class="hljs-keyword">res</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br><br><br>def backtracking(nums, path, <span class="hljs-keyword">res</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(nums):<br>        <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(path[:])<br>        <span class="hljs-keyword">return</span>  # 结束函数执行<br><br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">if</span> nums[i] in path:<br>            <span class="hljs-keyword">continue</span><br>        path.<span class="hljs-keyword">append</span>(nums[i])<br>        backtracking(nums, path, <span class="hljs-keyword">res</span>)<br>        path.<span class="hljs-keyword">pop</span>()<br><br><br><span class="hljs-keyword">print</span>(permutation(nums))<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-8-区间问题"><a href="#4-8-区间问题" class="headerlink" title="4.8 区间问题"></a>4.8 区间问题</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试准备</title>
    <link href="/2024/05/09/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/2024/05/09/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<p><strong>华为面试准备</strong></p><p>技能模板：</p><ul><li>熟悉软件测试理论基础、测试流程、测试用例设计方法和缺陷管理工具，如JIRA、禅道等。</li><li>熟练掌握Python+Selenium+WebDriver自动化测试框架，能够使用PO模式封装页面元素和操作方法，使用Excel和ddt进行数据驱动，使用pytest和allure生成测试报告，能够独立搭建WebUI自动化测试框架。</li><li>熟练使用Postman进行接口测试，能够构造请求参数和校验响应结果，使用Fiddler进行数据抓包和分析，能够定位前后端问题。</li><li>熟练使用JMeter进行性能测试，能够分析性能需求，设计性能场景，构造性能数据，执行性能测试，并分析性能指标和瓶颈。</li><li>熟练使用MySQL数据库，能够编写SQL语句进行数据查询和操作，保证数据的准确性和完整性。</li><li>熟悉APP测试，掌握ADB常用命令，能够使用Monkey对APP进行稳定性测试。</li><li>了解Git分布式版本控制系统。</li><li>了解基于Django框架的Web开发，了解HTML、CSS、Javascript、Bootstrap、Jquery等前端开发技术。</li></ul><ol><li><p>自我介绍</p><p>面试官您好，我叫黄杰，今年24岁，来自重庆合川，2021年毕业于重庆交通大学。毕业后有两段工作经历，第一份工作是在中建五局安装工程有限公司做暖通工程师，主要负责施工现场管理、暖通技术支持、施工图纸设计等。第二份工作是在一家社交类产品的互联网公司，做测试工程师，主要负责公司已上线产品的版本迭代测试，负责时间比较长的的移动端安卓产品的迭代测试工作。工作内容是以功能测试为主，也会包含部分接口测试、自动化测试、专项测试。</p><p>以上就是我的简单的自我介绍，谢谢面试官。</p></li><li><p>功能测试，工作内容包括哪些？</p><ul><li><strong>根据需求分析和设计测试用例</strong>：覆盖产品的各种功能和场景，确保测试用例的质量和有效性</li><li><strong>执行测试用例</strong>：使用浏览器调试助手、抓包工具等辅助工具，检查产品的功能是否符合预期，是否存在缺陷或问题</li><li><strong>提交和跟踪缺陷</strong>：使用专业的语言和格式，描述缺陷的重现步骤、影响范围和严重程度，与开发人员沟通和协调，验证缺陷的修复情况</li><li><strong>编写测试报告</strong>：总结测试过程中的发现、建议和改进，评估产品的质量和风险，为产品的发布提供参考</li><li><strong>协助完成其他相关工作</strong>：如平台配置、功能发布、视频录制、培训、问题解答、满意度调查等</li></ul></li><li><p>测试用例包含的 要素</p><ul><li><strong>用例编号</strong>：用来唯一标识每条测试用例，方便管理和跟踪。</li><li><strong>功能子模块</strong>：用来表示测试用例所属的功能模块或页面，便于分类和组织。</li><li><strong>测试目的</strong>：用来简要说明测试用例的目标和意义，让人一目了然。</li><li><strong>前置条件</strong>：用来描述测试用例执行之前需要满足的条件，比如数据准备、环境配置等。</li><li><strong>优先级</strong>：用来表示测试用例的重要性和紧急程度，一般分为高、中、低三个等级，指导测试人员安排测试顺序和时间。</li><li><strong>操作步骤</strong>：用来详细描述测试用例的具体操作过程，包括输入、点击、切换等动作，要清晰、完整、准确。</li><li><strong>输入数据</strong>：用来给出测试用例中涉及的参数或变量的具体值，要覆盖正常、异常、边界等情况。</li><li><strong>预期结果</strong>：用来给出测试用例执行后应该出现的结果或反馈，要与需求规格说明书保持一致。</li><li><strong>执行状态</strong>：用来表示测试用例是否已经被执行过，一般分为已执行和未执行两种状态。</li><li><strong>执行结果</strong>：用来表示测试用例执行后的实际结果或反馈，一般分为通过和不通过两种结果。</li><li><strong>对应jira bug-id</strong>：如果测试用例执行结果为不通过，需要在禅道上记录对应的bug，并填写bug的唯一id值，方便追踪和管理。</li><li><strong>编写人</strong>：用来记录测试用例的编写人员，便于沟通和负责。</li><li><strong>执行人</strong>：用来记录测试用例的执行人员，便于沟通和负责。</li><li><strong>备注</strong>：用来补充一些额外的信息，比如业务逻辑、规则、需求、预期结果等，让人看得更明白。</li></ul></li><li><p>黑盒测试和白盒测试的区别</p><ul><li>白盒测试需要从代码句法发现内部代码在算法，溢出，路径，条件等等中的缺点或者错误，进而加以修正。而黑盒测试着重测试软件功能，它并不涉及程序的内部结构和内容特性。黑盒测试并不能取代白盒测试，它与白盒是互补的测试方法，它很可能发现白盒测试不易发现的其他类型错误。</li><li>黑盒测试是从最终用户的角度进行的，而白盒测试是从开发人员的角度进行的</li><li>黑盒测试可以应用于软件测试的每个级别，如单元测试、集成测试、系统测试和验收测试，而白盒测试主要用于单元测试、集成测试和回归测试</li></ul></li><li><p>给你一个场景，设计测试用例</p><ol><li>功能需求、界面：验证软件是否能够打开聊天窗口，输入文本，限制字数在200字以内。</li><li>用户场景、易用性：验证软件是否能够支持不同的输入方式，如键盘、语音、表情等。验证软件是否能够显示输入的文本和字数。验证软件是否能够发送和接收文本消息。</li><li>边界条件：验证软件是否能够正确处理空输入、超过200字的输入、非法字符的输入等。验证软件是否能够提示用户输入错误或超出限制。</li><li>兼容性：验证软件是否能够在不同的平台、环境和设备上正常运行。验证软件是否能够适应不同的屏幕尺寸、分辨率和字体大小。</li><li>安全性：验证软件是否能够保护用户的隐私和数据安全。验证软件是否能够防止恶意攻击和篡改消息。</li></ol></li><li><p>安全测试相关</p><p>用来验证集成在系统内的保护机制是否能够在实际中保护系统不受到非法的侵入。</p><p>常见的有：</p><p><strong>sql注入，DDOS（分布式拒绝服务攻击）, Cookie欺骗、认证和授权、xss攻击、</strong></p><p>DDoS是Distributed Denial of Service的缩写，意思是“分布式拒绝服务”。DDoS攻击是一种恶意的网络攻击，通过利用多个被感染的计算机或设备（称为botnet）向目标服务器、服务或网络发送大量的流量，从而使其无法正常运行。DDoS攻击的目的是阻断正常用户的访问，给目标造成金钱或信誉上的损失。</p><p>SQL注入是一种web安全漏洞，使攻击者可以在应用程序对数据库执行的SQL查询中插入恶意代码。这可能导致攻击者查看、修改或删除数据库中的敏感数据，或者执行其他恶意操作。SQL注入的本质是把用户输入的数据当作代码来执行，违背了“数据与代码分离”的原则。SQL注入的产生需要满足以下两个条件：1、参数用户可控：前端传给后端的参数用户可控。2、参数带入数据库查询：传入的参数拼接到SQL语句中，且带入数据库中查询。</p><p>Cookies欺骗是通过盗取、修改、伪造Cookies的内容来欺骗Web系统,并得到相应权限或者进行相应权限操作的一种攻击方式。</p></li><li><p>常用的linux命令</p><ol><li><p>目录管理 cd pwd ls ll mkdir rmdir mv cp</p></li><li><p>文件管理 </p><ol><li>文件操作命令 touch <strong>vi</strong> cp mv rm ln wc</li><li>文件查看操作 <strong>cat</strong> head more less <strong>tail</strong> find sort **grep ** file</li><li>文件比较操作 diff cmp  which</li></ol></li><li><p>用户管理 useradd(adduser) passwd usermod userdel groupadd </p></li><li><p>权限管理 <strong>chmod</strong> chown chgrp</p></li><li><p>系统设置 alise echo export</p></li><li><p>网络通信 <strong>ifconfig</strong> hostname netstat(显示网络状态) ping </p></li><li><p>磁盘管理 df fu <strong>top</strong> <strong>ps</strong>(ps -ef 或者ps -aux查看所有进程 ，杀掉进程kill -9 pid) vmstat(显示虚拟内存)</p></li><li><p>备份压缩 gzip&#x2F;gunzip <strong>tar</strong> zip&#x2F;unzip</p><p>•cvf-只对文件进行打包，没压缩</p><p>•xvf-对.tar 文件进行解包</p><p>•zcvf-打包同时实现压缩，生成.tar.gz</p><p>•zxvf-对压缩后的打包文件进行解压</p></li><li><p>其他 clear date shutdown poweroff&#x2F;reboot</p></li></ol></li><li><p>黑盒测试和白盒测试的常用方法</p><ol><li><p>黑盒：</p><ol><li>等价类划分法：把所有可能的输入数据划分为若干个互不相交的子集，称为等价类，然后从每个等价类中选取代表性的数据作为测试用例。</li><li>边界值分析法：选取正好等于、刚刚大于或刚刚小于等价类边界的值作为测试数据，因为边界是最容易出错的地方。</li><li>因果图法：根据软件规格说明中的原因和结果，画出因果图，然后转换为决策表，设计测试用例。</li><li>场景法：根据用户使用软件的场景或情境，设计测试用例。</li><li>正交实验设计法：利用正交表选择最优的测试组合，减少测试用例的数量。</li><li>判定表驱动分析法：把作为条件的所有输入的各种组合值以及对应输出值都罗列出来而形成的表格，称为决策表，利用决策表设计测试用例。</li><li>错误推测法：根据经验或直觉推测可能出现错误的地方，设计测试用例。</li></ol></li><li><p>白盒：</p><ol><li>语句覆盖法：要求每条可执行语句至少执行一次。</li><li>判定覆盖法：要求每个判定结构至少有真、假两种结果。</li><li>条件覆盖法：要求每个判定条件至少有真、假两种结果。</li><li>判定&#x2F;条件覆盖法：要求每个判定结构和每个判定条件都至少有真、假两种结果。</li><li>条件组合覆盖法：要求每个判定结构中所有可能的条件组合都至少出现一次。</li><li>路径覆盖法：要求程序中所有可能的路径都至少执行一次</li></ol></li></ol></li><li><p>接口测试相关</p><ol><li><p>接口类型</p><ul><li>对外接口：全面性测试</li><li>对内接口：漏洞测试、破坏性测试</li></ul></li><li><p>postman</p></li><li><p>数据埋点测试</p><p>埋点是在程序中的某个位置加上一个标记，当用户触发到某个行为的时候，就采集一下数据，然后将数据上报到某个位置进行存储，埋点的最终目的是收集到相关的数据，提供数据支撑。</p><p>上家公司是使用的第三方统计平台，GIO。</p></li></ol></li><li><p>专项测试相关</p><ol><li><strong>兼容性测试</strong>：测试App在不同的操作系统版本、屏幕分辨率、厂商ROM和网络类型下的功能和性能表现。</li><li><strong>流量测试</strong>：测试App在用户操作和后台运行时的流量消耗情况，优化流量使用效率。</li><li><strong>电量测试</strong>：测试App在不同的使用场景下的电量消耗情况，优化电池使用寿命。</li><li><strong>弱网络测试</strong>：测试App在网络不稳定、信号弱、中断等情况下的功能和性能表现，优化网络请求和缓存机制。</li><li><strong>稳定性测试</strong>：测试App在长时间运行或高压力下的稳定性，避免出现闪退、卡死、内存泄漏等问题。</li><li><strong>安全测试</strong>：测试App的安装包、敏感信息、账户密码、数据通信等方面的安全性，防止被反编译、劫持、注入、攻击等。</li><li><strong>环境相关测试</strong>：测试App在不同的用户环境下的功能和性能表现，考虑干扰因素、权限设置、第三方依赖、冲突场景等。</li></ol></li><li><p>性能测试（稳定性测试、压力、负载）</p><ol><li><p>用来测试软件在集成系统中 的运行性能的</p></li><li><p>性能测试的目标是度量系统相对于预定义目标的差距</p></li><li><p>性能测试工具，如Loadrunner, Jmeter, SilkPerformer, WebLoad</p></li><li><p>性能测试主要指标</p><ol><li><p>外部 </p><p>• 吞吐量：每秒钟系统能够处理的请求数、任务数 </p><p>• 响应时间：服务处理一个请求或一个任务的耗时 </p><p>• 错误率：一批请求中结果出错的请求所占比例</p></li><li><p>内部 </p><p>• 服务器的CPU、内存、网络、磁盘IO等</p></li></ol></li></ol></li><li><p>测试模型</p><p>​</p></li><li><p>怎么做好测试？</p></li><li><p>操作系统相关</p></li><li><p>from collections import Counter</p></li><li><p>测试的目的：发现被测试的产品和用户需求的差异，也就是缺陷</p><p>• 尽早介入测试发现缺陷，减少返工、降低开发维护成本</p><p>• 持续改进过程，帮助定义需求和设计</p><p>• 提高客户满意度，扩大市场份额</p><p>• 对产品质量完成全面评估、为产品发布、部署、鉴定和决策者提供信息</p><p>• 预防缺陷，通过缺陷分析和原因总结，规避后续同类缺陷的产生再犯</p></li><li><p>数据库mysql相关</p><ol><li><p>数据库模式定义语言DDL(Data Definition Language) </p><ol><li>CREATE</li><li>ALTER</li><li>DROP</li><li>TRUNCATE</li></ol></li><li><p>数据操作语言DML（Data Manipulation Language），用户通过它可以实现对数据库的基本操作</p><p>在DML中，应用程序可以对数据库作插，删，改，排，检等五种操作。</p><ol><li>INSERT</li><li>UPDATE</li><li>DELETE</li><li>SELECT</li></ol></li><li><p>查询语句标准格式</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> 字段 <br><span class="hljs-keyword">from</span> 表<br><span class="hljs-keyword">where</span> 条件<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 字段<span class="hljs-number">1</span>，字段<span class="hljs-number">2.</span>.；<br></code></pre></td></tr></table></figure></li><li><p>多表连接</p><ol><li>等值连接</li><li>不等连接</li><li>外连接（左连接、右连接）</li><li>自连接</li></ol></li><li><p>分组查询</p></li><li><p><img src="/../imgs/1715185646815.png" alt="1715185646815"></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> 字段 <br><span class="hljs-keyword">from</span> 表<br><span class="hljs-keyword">where</span> 条件<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组条件<br><span class="hljs-keyword">having</span> 符合条件的组<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 字段<span class="hljs-number">1</span>，字段<span class="hljs-number">2.</span>.；<br></code></pre></td></tr></table></figure></li><li><p>子查询</p></li></ol></li><li><p>IM push推送机制</p><p><a href="http://www.taodudu.cc/news/show-546423.html?action=onClick">http://www.taodudu.cc/news/show-546423.html?action=onClick</a></p><p>实现原理：</p><ol><li>应用服务器与推送服务器建立长连接。</li><li>应用服务器把推送请求和对应的消息内容 发送给推送服务器。</li><li>推送服务根据应用服务器传递的参数推送到指定的设备上。</li></ol><p>Android：海外谷歌FCM、国内是各厂商通道push和第三方通道PUSH</p><p>IOS：APNS</p><p>发现的印象深刻的问题：</p><ol><li><p>push重复发送</p><p>原因：推送了一条非透传消息，本来应该手机系统服务去解析这个通知然后展示到通知栏，但是app也去解析了一次，所以展示了两条一样的消息。解决办法：app不去解析。</p><p>透传是指数据传输时，不对数据做任何特殊的处理，原封不动地发送给接收方。也就是说，透传的通道完全“透明”的，它不管发送方传输的是什么数据，只负责将数据送到接收方手上即可，接收方可以直接解析出发送方发送的数据信息。</p><p>非透传则是指数据传输时，需要在数据传输前对数据进行加密或者压缩等操作，然后再进行传输。当接收方收到数据时，需要对加密或者压缩后的数据进行解密或者解压缩操作，才能获得真正的数据信息。所以，非透传通常需要使用特定的协议和算法来实现。</p><p><a href="https://www.iotrouter.com/news/1263.html">https://www.iotrouter.com/news/1263.html</a></p></li><li><p>通知过多会崩溃</p><p>原因：数组越界。客户端写的接收push的数组比较小，扩大了内存。</p></li><li><p>push交互区域是整个区域</p><p>原因：安卓开发错误使用了dialog函数。解决办法：修改了函数。</p></li></ol></li><li><p>Cookie、Session、Token区别在哪？</p><ol><li>session是诞生并保存在服务器，由服务器主导一切。</li><li>cookie是一种数据载体，把session放在cookie中送到客户端，cookie跟随每个http请求发送出去。</li><li>Token是诞生在服务器，但保存在浏览器，由客户端主导一切。可以放在cookie或Storage里面。持有Token就像持有令牌一样可以访问服务器。</li></ol><p>由于http是无状态的，想要实现保持登录，需要依靠cookie，cookie是一种可以实现每次http请求都自带数据给服务器的的技术。说白了Cookie就是一种存储在浏览器的数据而已。</p><p><img src="/../imgs/1715185663670.png" alt="1715185663670"></p><p>Session：当你登录成功后，在服务器生成SessionID和会话结束时间（以及一些其他参数），服务器Set-Cookie并且把SessionID加入Cookie，会话结束时间设置为cookie的有效期，浏览器拿到并保存Cookie，再依靠Cookie特性（每次http请求都会带上cookie）实现保持登录，直到Cookie的有效期失效，浏览器自行删除这个Cookie。</p><p>SessionID：是没有规律的字符串，服务器再发送Cookie之前会对这个含有SessionID的Cookie进行签名，所有是有一定安全性的。 </p><p><img src="/../imgs/1715185677335.png" alt="1715185677335"></p><p>由于用户体量的增加，服务器存储SessionID会引发很多不合理的地方，就诞生了新的技术JWT(JSON Web Token)。token是通过加密算法生成一个加密字符串，包含了用户的身份和权限信息，客户端每次请求都带上这个token，服务器端根据密钥解密token进行验证。</p><p>JWT是由三部分组成的：header.payload.·</p><ul><li><p>header 声明需要用什么算法来生成签名</p></li><li><p>payload 一些特定数据，比如有效期之类</p></li><li><p>signature签名</p><p><img src="/../imgs/1715185697160.png" alt="1715185697160"></p></li></ul><p><img src="/../imgs/1715185708040.png" alt="1715185708040"></p><p>​</p></li><li><p>网络协议模型</p><ol><li><p><strong>物理层协议</strong>：负责定义物理设备如何传输数据，例如双绞线、光纤、无线电波等。</p></li><li><p><strong>数据链路层协议</strong>：负责在物理层之上建立逻辑连接，确定数据的分组方式和意义，例如以太网、ARP、MAC等。</p></li><li><p><strong>网络层协议</strong>：负责在网络中进行寻址和路由，实现不同网络之间的互联，例如IP、ICMP、IGMP等。</p></li><li><p><strong>传输层协议</strong>：负责在网络层之上提供可靠或不可靠的数据传输服务，例如TCP、UDP等。</p></li><li><p><strong>应用层协议</strong>：负责定义应用程序之间的通信规则，例如HTTP、FTP、SMTP、DNS等</p></li></ol></li><li><p>python相关知识：</p><ol><li><p>sort和sorted底层实现原理</p><p>timsort算法，可以简单理解为 归并排序 和 二分插入排序 算法的混合体，号称世界上最好的排序算法。</p></li><li><pre><code class="hljs">__init__ 和 __new__</code></pre><p>相同点：</p><ol><li>都是类中的内置方法</li><li>都会在创建对象时自动调用</li></ol><p>不同点：</p><ol><li>new是创建实例，init是初始化实例</li><li>new方法在init方法之前被调用</li><li>new是类方法，init是实例方法</li></ol></li><li><p>Python除了全局作用域和局部作用域，还有哪些作用域？</p><p>嵌套作用域是指在一个函数内部定义另一个函数，内部函数可以访问外部函数的变量；</p><p>内置作用域是指Python预定义的一些变量和函数，例如print、len、range等</p></li><li><p>深拷贝、浅拷贝？</p><ul><li><p>浅拷贝</p><p>python拷贝一般都是浅拷贝，拷贝时，对象包含的子对象不拷贝，因此，源对象与拷贝对象会引用同一个子对象。</p></li><li><p>深拷贝</p><p>使用copy模块deepcopy函数，递归拷贝对象中包含子对象，源对象和拷贝对象所有的子对象也不相同。</p></li></ul></li></ol></li><li><p>婚恋社交产品核心功能：</p><ul><li><p><strong>实名认证</strong>：要求每一位注册的用户提供真实有效的资料，通过平台的认可方可进入。这样可以保证用户的安全和信任，也可以提高用户的质量和活跃度</p></li><li><p><strong>在线聊天</strong>：用户可以和朋友用语音和文字进行沟通交流是社交APP的首要功能，除此之外，还可实现视频通话，更加近距离的接触</p></li><li><p><strong>群聊互动</strong>：可支持2人以上的群组聊天，邀请共同兴趣爱好的人进入同一个群，方便彼此之间的交流</p><ul><li>聊天功能、消息管理、消息推送、权限管理、隐私管理、成员管理、网络环境、兼容测试</li></ul></li><li><p><strong>陌生交友</strong>：通过社交APP，用户可以扩大自己的交往的圈子，还可以很快结交到有着相同兴趣爱好的朋友</p></li><li><p><strong>社交圈</strong>：用户可以发表自己的心情、照片，随时随地与家人、朋友分享自己的经历</p></li><li><p><strong>定位服务</strong></p><ul><li><strong>使用系统自带的定位服务和GPS</strong>：这种方法是利用手机系统自带的定位服务和GPS功能，来获取用户的经纬度和地址信息。这种方法需要用户授予app使用位置的权限，并且可能受到磁场或其他环境的干扰</li><li><strong>使用外接SDK</strong>：这种方法是利用第三方提供的软件开发包（SDK），如高德SDK、百度SDK等，来获取用户的经纬度和地址信息。这种方法也需要用户授予app使用位置的权限，并且可能需要申请开发者账号和密钥</li><li><strong>使用外部接口</strong>：这种方法是利用外部提供的接口，如百度API、聚合数据API等，来获取用户的外网IP地址，然后根据IP地址推测用户的大致位置。这种方法不需要用户授予app使用位置的权限，但是可能不够准确，并且可能需要申请开发者账号和密钥</li></ul></li></ul></li><li><p>手撕算法题</p><p>题目难度和范围接近OD笔试，以LeetCode中的简单题和中等题为主，而且考察种子题的概率更大。所谓种子题，是指各种算法中最基础的那些题目，比如</p><ol><li>二分查找：LC35搜索插入位置</li><li>滑动窗口：LC3无重复字符的最长子串</li><li>DFS和BFS：LC200岛屿面积</li><li>回溯：LC46全排列</li><li>动态规划：LC300最长递增子序列等等</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>playwright</title>
    <link href="/2024/05/08/playwright/"/>
    <url>/2024/05/08/playwright/</url>
    
    <content type="html"><![CDATA[<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs clean"># <span class="hljs-keyword">import</span> time<br>#<br># <span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> Playwright, sync_playwright<br># <span class="hljs-keyword">import</span> subprocess<br>#<br># # 输入 Chrome 浏览器所在路径，并使用双引号将路径括起来<br># # chrome_path = <span class="hljs-string">&#x27;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#x27;</span><br># chrome_path = <span class="hljs-string">&quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe&quot;</span><br># debugging_port = <span class="hljs-string">&#x27;--remote-debugging-port=9223&#x27;</span><br>#<br># # 使用列表形式表示命令及其参数<br># command = [chrome_path, debugging_port]<br># subprocess.Popen(command)<br>#<br>#<br># def run(playwright: Playwright) -&gt; None:<br>#     # browser = playwright.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>#     time.sleep(<span class="hljs-number">4</span>)<br>#     browser = playwright.chromium.connect_over_cdp(<span class="hljs-string">&#x27;http://localhost:9223&#x27;</span>)<br>#     default_context = browser.contexts[<span class="hljs-number">0</span>]<br>#     page = default_context.pages[<span class="hljs-number">0</span>]<br>#     print(page)<br>#<br>#     page = default_context.new_page()<br>#     page.goto(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>#<br>#<br># # 在这里调用 run() 函数<br># <span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> playwright:<br>#     run(playwright)<br><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> Playwright, sync_playwright<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> playwright:<br>    browser = playwright.chromium.launch_persistent_context(<br>        # 指定本机用户缓存地址<br>        user_data_dir=r<span class="hljs-string">&quot;C:\Users\Jay\Desktop\截图\user&quot;</span>,<br>        # 指定本机google客户端exe的路径<br>        executable_path=<span class="hljs-string">&quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe&quot;</span>,<br>        # 要想通过这个下载文件这个必然要开  默认是<span class="hljs-literal">False</span><br>        accept_downloads=<span class="hljs-literal">True</span>,<br>        # 设置不是无头模式<br>        headless=<span class="hljs-literal">False</span>,<br>        bypass_csp=<span class="hljs-literal">True</span>,<br>        slow_mo=<span class="hljs-number">10</span>,<br>        # 跳过检测<br>        args=[<span class="hljs-string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>, <span class="hljs-string">&#x27;--remote-debugging-port=9222&#x27;</span>]<br><br>    )<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://console.ccpayment.com/balances/index&quot;</span>)<br>    # time.sleep(<span class="hljs-number">1000</span>)<br>    page.get_by_role(<span class="hljs-string">&quot;row&quot;</span>, name=<span class="hljs-string">&quot;logo TETH&quot;</span>).get_by_role(<span class="hljs-string">&quot;button&quot;</span>).nth(<span class="hljs-number">1</span>).click()<br>    page.get_by_label(<span class="hljs-string">&quot;Enter Address&quot;</span>).click()<br>    page.get_by_label(<span class="hljs-string">&quot;Enter Address&quot;</span>).fill(<span class="hljs-string">&quot;0x12438F04093EBc87f0Ba629bbe93F2451711d967&quot;</span>)<br>    page.get_by_label(<span class="hljs-string">&quot;Amount&quot;</span>).click()<br>    page.get_by_label(<span class="hljs-string">&quot;Amount&quot;</span>).fill(<span class="hljs-string">&quot;0.002&quot;</span>)<br>    page.get_by_role(<span class="hljs-string">&quot;button&quot;</span>, name=<span class="hljs-string">&quot;Send&quot;</span>).click()<br>    page.get_by_label(<span class="hljs-string">&quot;Payment Password&quot;</span>).click()<br>    page.get_by_label(<span class="hljs-string">&quot;Payment Password&quot;</span>).fill(<span class="hljs-string">&quot;111111&quot;</span>)<br>    page.get_by_role(<span class="hljs-string">&quot;button&quot;</span>, name=<span class="hljs-string">&quot;Confirm&quot;</span>).click()<br>    time.sleep(<span class="hljs-number">2</span>)<br>    page.get_by_label(<span class="hljs-string">&quot;close&quot;</span>).click()<br>    # print(page.title())<br>    time.sleep(<span class="hljs-number">200</span>)<br>    browser.close()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/05/07/hello-world/"/>
    <url>/2024/05/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
